./ ADD NAME=$$README 0104-00271-02128-1559-00283-00030-00255-BC0THOR
This PDS contains a number of members whose names begin with CBC3....
that are the C Language (not C++) sample programs contained in
CBC.SCBCSAM. Some of these have been modified slightly for one reason
or another - usually to correct minor errors.

IBM provided set of mainframe C language programs to illustrate use of
the C language in the mainframe environment. Of particular value are
those showing how to access mainframe datasets, including QSAM and VSAM
and also use of the decimal data type to process packed decimal data.

Sample JCL to execute these programs is contained in the SAMPJCL library

Members whose names do NOT begin with CBC3.... are utilities placed here
to aid in the use of the C Language on the mainframe.

1. CBRAKETS is a program that converts square brackets and circumflexes
   to the values needed by the compiler. Unfortunately, there are
   several different notions of what these characters should be. I have
   done the following to aid in use of C on the mainframe:
   a) In Reflection, I remap the square brackets and circumflex (the hat
      character, shift-6) to display the ANSI value for these characters
      rather than the vertical-bar, cent-sign, and not-sign that is the
      default. This causes them to display properly on the screen in
      TSO ISPF EDIT. However, the compiler does not recognize them in
      this form.
   b) There is a CLIST named BKT that I keep in my CLIST library when
      doing C that converts several varieties of square brackets to the
      value that is displayed properly in TSO ISPF EDIT. When beginning
      an EDIT session with a new C program, I issue the BKT command to
      convert so that brackets are displayed properly. (The compiler
      uses values that display as a capital Y with a dot over it for
      left bracket, and an umlaut - double dot that looks almost like
      a double quote as a right bracket).
   c) To make the compiler happy, I run the C source program through
      the CBRAKETS program before compiling. The only downside to this
      is that header files must be left in compiler form, as they do
      not go through CBRAKETS.
2. CCMP is a CLIST that can be used to compile and bind the program
   currently in the ISPF EDIT window. It invokes edit macro CEDIT and
   passes the name of the current source member. CEDIT applies the
   member name to the JCL in EDCCB and submits the resulting job,
   which converts brackets to compiler expected values, compiles the
   resulting source, and binds (linkedits) the program into your load
   library. To use, copy CCMP and CEDIT into your CLIST library, and
   EDCCB into your JCL library. Edit all three to use your dataset
   names before use.

3. OPEN statements for files differ on the mainframe from normal PC
   use. Some examples are:

  fopen("asa.file", "w,recfm=fba");
  fopen("test.file","wb, recfm=f, lrecl=80");
  fopen(qual_pds,"rb");
  fopen("a.b(memnm)","r");
  fopen("mygdg(+1)","a,recfm=f");
  fopen("a.b","w+");
  fopen("dd:vsamesds","rb,type=record");
*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*
*                 Sample Programs in this PDS                         *
*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

CBC3GAS1 OK  Writes to an ASA file.

CBC3GCL1 OK  Gets local time from current locale.

CBC3GDC1 OK  Demonstrates arithmetic using decimal variables.

CBC3GDC2 OK  Shows use of relational expression with decimal variables.

CBC3GDC3 OK  Demonstrates use of decimal data type.

CBC3GDC4 OK  Demonstrates use of decimal data type.

CBC3GDI1 OK  Prints the __AMRC Structure. (Long run: writes until B37).

CBC3GDI2 OK  Shows SIGIOERR use. (Long run: writes until B37).

CBC3GDLI OK  Shows how to tell if SAA C or POSIX locale is in effect.

CBC3GEV1 OK  Demonstrates how Environment Variables are propagated.

CBC3GHF1 OK  Demonstrates use of unnamed pipes.

CBC3GHF2 XX  Shows use of named pipes. Program needed a #define and
             several #include statements to compile correctly. Gets
             errno=134 in execution.

CBC3GHF3 XX  Uses HFS Stream I/O. Gets error opening file: function not
             implemented.

CBC3GIP0 OK  This is a locally written main() which calls the subroutine
             in CBC3GIP1 to read a PDS directory.

CBC3GIP1 OK  This is a set of subroutines that can be used to obtain
             a list of PDS member names. It requires a MAIN program

CBC3GIS3 OK  Used to show ISPF panel use. Had to add #include for
             string.h and prototype for ISPLINK to compile RC=0.
             uses CLIST CBC3GIS1 in File 561 and panels CBC3GIS2,
             CBC3GIS4, and CBC3GIS5 in File 562.

CBC3GIS8 OK  Used to show ISPF panel use. Had to correct the #pragma
             and #extern and prototype statements for ISPLINK to make
             it compile with RC=0. uses CLIST CBC3GIS6 in File 561 and
                            panels CBC3GIS7 and CBC3GIS4 in File 562.

CBC3GMF1 OK  Illustrates creation of PDS dataset members (and the PDS
             if it doesn't pre-exist), and deletion of a PDS member.
             This sample is modified from the original.


CBC3GMF2 OK  Shows how to rename a PDS (or any flat file). This is a
             modification of the original program.

CBC3GMT1 OK  Multi-tasking Facility Sample 1. This program produces
             the sum of a series of products of numbers in its input
             datasets, but does no MTA functions. It probably was
             intended as a comparison to the true MTA sample, CBC3GMT2.

CBC3GMT2 XX  Multi-Tasking Facility Sample 2. This program produces no
             output, though compiles and execution are error free.

CBC3GMV1 OK  Displays C Language variant characters in hex as they are
             supplied in a dataset, and as the compiler expects them.

CBC3GOF1 OK  Shows memory file usage with the type=memory operand of
             the fopen() function.

CBC3GOP1 XX  Show effects of optimization (?). Compile error on:
                inline int which_group(int a) {
                CBC3277 Syntax error: possible missing ';' or ','?
                CBC3485 Parameter declarator list is incompatible with
                        declarator for inline.

CBC3GOP2 XX  Shows effects of optimization (?). Produces no output.

CBC3GOP3 XX  Demonstrates how numeric conversions are done. Produces no
             output.

CBC3GOS1 OK  This example demonstrates GDG I/O. It contains JCL to
             create a GDG. The C program is compiled and run in-line
             and fails (deliberately) as it attempts to open the GDG
             with incorrect file charactersitics.

CBC3GOS3 OK  This example shows how updated records are read.

CBC3GRE1 OK  Shows how to make strings constant. Displays "Hello World"

CBC3GRE3 XX  Assembler subroutine part of CBC3GRE4 sample. Assembles
             clean but gets binder errors when combined with CBC3GRE4.

CBC3GRE4 XX  Shows how an assembler program can reference objects in
             the writable static area. Compiles clean, but gets link
             errors when combined with CBC3GRE3.

CBC3GVS1 OK  Demonstrates VSAM ESDS use and how to access the
             __amrc->__RBA field.

CBC3GVS2 OK  Demonstrates VSAM KSDS use. Execution JCL is CBC3GVS3.

CBC3GVS4 OK  Demonstrates VSAM RRDS use.

CBC3GTH1 ??  Uses thread-specific data to insure that storage acquired
             by a specific thread is freed when the thread ends.
             Compiled, ran clean, but no output, so did it work?

CBC3GWT2 OK  C program calls an assembler subroutine to display a
             messge. The C program CBC3GWT2 had a coding error in the
             #pargma statement, in which dynwto should have been DYNWTO.

CBC3RAA  OK  Shows use of the switch statement with break. A fourth
             value was added to the enum to permit testing the default
             for the switch instruction.

CBC3RAAA OK  A simple C program that calls the cos() function and
             displays the result using printf().

CBC3RAAB OK  Sample of a C program calling another C program, passing
             and receiving parameters.

CBC3RAAD OK  Show use of character constants.

CBC3RAAE OK  Demonstrates use of string constants with the string
             functions strcpy() and strcat().

CBC3RAAF OK  Illustrates how auto variables are unique within the block
             in which they are defined. Shows call to another function
             defined in the same program.

CBC3RAAG OK  Sample to show how to read data from SYSIN, build a char-
             acter string, pass the string to an included function,
             where it is sorted. On return the sorted string is printed.

CBC3RAAI OK  Uses external variables (defined outside a program block)
             for the same purpose as CBC3RAAG.

CBC3RAAK OK  Shows use of block scope static variables.

CBC3RAAM OK  This example uses the void data type.

CBC3RAAN OK  Illustrates use of the enum type.

CBC3RAAO OK  This example uses a one-dimensional array.

CBC3RAAP OK  This example uses a multi-dimensional array.

CBC3RAAQ OK  This program searches for the first occurrence of a
             character string in an array of character strings.

CBC3RAAR ??  This example uses an abstract data type and a header file
             CBC3RAR1. Difficult to tell if ti worked properly, as there
             is no output.

CBC3RAAS OK  This program illustrates linked lists.

CBC3RAAT OK  THIS EXAMPLE USES AN ARRAY OF POINTERS TO FUNCTIONS.

CBC3RAAU OK  This example uses a prototype function declarator.

CBC3RAAV OK  This example shows how a function is declared and defined.

CBC3RAAX OK  This example shows how a parameter is passed to a function.

CBC3RAAY OK  This example shows how an address is passed to a function.

CBC3RAAZ OK  This example shows how loss of precision occurs during type
             conversion.

CBC3RAA1 OK  This example shows how the values of data objects change in
             nested blocks.

CBC3RAA2 OK  This program counts the characters in the strings that are
             part of an array of pointers to characters.
             The count stops when one of the digits 0 through 9 is
             found and resumes at the beginning of the next string.

CBC3RAA3 OK  This example shows how the continue statement can be used.

CBC3RAA4 OK  This program counts the characters in strings that are part
             of an array of pointers to characters. The count excludes
             the digits 0 through 9.

CBC3RAA5 OK  This example illustrates the do statement.

CBC3RAA6 OK  This example shows how a goto statement may be used.

CBC3RAA7 OK  This example shows how the while statement may be used.

CBC3RAA8 OK  This example illustrates the use of a macro.

CBC3RAA9 OK  This example is equivalent to CBC3RAA8.

CBC3RABA OK  This example shows how predefined macros are used.

CBC3RABB OK  This example shows how predefined macros are used.

CBC3RABC OK  This example uses conditional compilation directives.

CBC3RABD OK  This example shows how #line is used.

CBC3RABE OK  This example shows how #pragma inline may be used.

CBC3RABF OK  This example illustrates blocks, nesting, and scope.

CBC3RABG OK  This example prints out ctest characters.

CBC3RABI OK  This example shows how the switch statement may be used.

CBC3RAH1 OK  This example shows the linkage of extern objects/functions.
             In this file, the program receives the price of an item,
             adds the tax, and prints the total cost of the item.

CBC3RAJ1 OK  This program illustrates the use of file scope static
             variables.

CBC3UAAM OK  Converts celsius temperatures to fahrenheit.

CBC3X06C OK  This example illustrates function calls.

CBC3X08A ok  This example illustrates the __FUNCTION__ predefined macro
             in a C program.

CBC3YIV1 OK  Echo arguments to STDOUT.
./ ADD NAME=BKT      0100-00271-00271-1533-00048-00048-00000-BC0THOR
/*********************************************************************/
/*   PURPOSE: CONVERTS BRACKETS FOR EDITING C LANGUAGE SOURCE AND    */
/*            PROVIDES A COUNT OF THE LEFT AND RIGHT BRACKETS FOR    */
/*            VALIDATION. FIRST, CONVERTS ALL TRIGRAPH AND TRUE HEX  */
/*            BRACKET VALUES TO THOSE USABLE IN TSO/ISPF EDIT, THEN  */
/*            COUNTS THE LEFT AND RIGHT BRACKETS AND REPORTS ANY     */
/*            INEQUALITY. CIRCUMFLEX ALSO CONVERTED.                 */
/*   AUTHOR:  BC0THOR BASED ON IBM MANUAL. CREATED: 08/14/2000       */
/*   TYPICAL USER(S): BC0THOR                                        */
/*   PARAMETERS PASSED: NONE                                         */
/*   CDC COMPLIANCE: NO DATE DEPENDENCIES                            */
/*********************************************************************/
/*               MAINTENANCE RECORD: LAST 3 CHANGES                  */
/*********************************************************************/
/*   DATE    LOGONID REASON FOR CHANGE & WHAT WAS DONE               */
/*-------------------------------------------------------------------*/
/*                                                                   */
/*********************************************************************/
PROC 0 DEBUG(     )
ISREDIT MACRO
CONTROL NOLIST NOSYMLIST NOCONLIST MSG
IF &DEBUG = DEBUG THEN CONTROL LIST CONLIST SYMLIST
/* CALL 'TEST.LOAD(CLISTMON)' 'BKT     '  */
ISREDIT CHANGE ALL C'??(' X'BA'    /*********************************/
ISREDIT CHANGE ALL C'??)' X'BB'    /* CONVERT TRIGRAPHS, X'AD' AND  */
ISREDIT CHANGE ALL X'AD' X'BA'     /* X'BD' TO THE ISPF EDIT VALUES */
ISREDIT CHANGE ALL X'BD' X'BB'     /* X'BA' AND X'BB'.              */
                                   /*********************************/
ISREDIT CHANGE ALL X'5F' X'B0'     /* CIRCUMFLEX (HAT)              */

ISREDIT FIND C']' ALL NX
ISREDIT (N1) = FIND_COUNTS
ISREDIT FIND C'[' ALL NX
ISREDIT (N2) = FIND_COUNTS
IF (&N1 ¬= &N2) THEN WRITE UNBALANCED BRACKETS: &N1 LEFT, &N2 RIGHT

ISREDIT FIND C'(' ALL NX
ISREDIT (N1) = FIND_COUNTS
ISREDIT FIND C')' ALL NX
ISREDIT (N2) = FIND_COUNTS
IF (&N1 ¬= &N2) THEN WRITE UNBALANCED PARENTHESES: &N1 LEFT, &N2 RIGHT

ISREDIT FIND C'{'  ALL NX
ISREDIT (N1) = FIND_COUNTS
ISREDIT FIND C'}' ALL NX
ISREDIT (N2) = FIND_COUNTS
IF (&N1 ¬= &N2) THEN WRITE UNBALANCED CURLY BRACES: &N1 LEFT, &N2 RIGHT
END
./ ADD NAME=CBC3GAS1 0101-00223-00257-1008-00039-00025-00000-BC0THOR
/*********************************************************************/
/* This example shows how to write to an ASA file. a file for output */
/* with recfm=fba is opened and several records are written to it:   */
/*  1. abcdef with doublespace before                                */
/*  2. 345 with skip-to-head-of-form before                          */
/*  3. 9034 with four spaces before                                  */
/* Notes:                                                            */
/*  1. When fopen supplies a dsname, the file is opened if is is an  */
/*     existing, cataloged dataset. If not, it is dynamically created*/
/*  2. When fopen supplies a ddnane, the dd statement supplied in the*/
/*     execution time jcl is used, if present. if not present, a     */
/*     temporary file is allocated and deleted at end of job.        */
/*********************************************************************/

#include <stdio.h>
#define MAX_LEN 80

int main(void) {
   FILE *fp;
   int i;
   char s[MAX_LEN+1];

/* fp = fopen("asa.file", "w, recfm=fba"); /* open userid.asa.file   */
   fp = fopen("dd:print1", "w, recfm=fba"); /* open ddname print1    */
   if (fp != NULL) {
      fputs("\n\nabcdef\f\r345\n\n", fp);
      fputs("\n\n9034\n", fp);
      fclose(fp);

   return(0);
   }

/* fp = fopen("asa.file", "r");             /* open userid.asa.file  */
   fp = fopen("dd:print1", "r");            /* open ddname print1    */
   for (i = 0; i < 5; i++) {
     fscanf(fp, "%s", &s[0]);
     printf("string = %s\n",s);
   }
}
./ ADD NAME=CBC3GCL1 0101-00223-00257-1011-00034-00028-00000-BC0THOR
/*********************************************************************/
/* This example shows how to get the local time formatted by the     */
/* current locale.                                                   */
/* Note that the output from the printf function is written to the   */
/* SYSPRINT dd statement, if it is supplied in the execution JCL. If */
/* not, the printf output is dynamically allocated to a SYSOUT=A     */
/* file.                                                             */
/*********************************************************************/

#include <stdio.h>
#include <time.h>
#include <locale.h>

int main(void){
    char dest[80];
    int ch;
    time_t temp;
    struct tm *timeptr;
    temp = time(NULL);
    timeptr = localtime(&temp);
    /* Fetch default locale name */
    printf("Default empty_str locale is %s\n",setlocale(LC_ALL,""));
    ch = strftime(dest,sizeof(dest)-1,
      "Local C datetime is %c", timeptr);
    printf("%s\n",  dest);

    /* Set new Texan locale name */
    printf("New locale is %s\n", setlocale(LC_ALL,"Texan.IBM-1047"));
    ch = strftime(dest,sizeof(dest)-1,
      "Texan datetime is %c ", timeptr);
    printf("%s\n", dest);

    return(0);
}
./ ADD NAME=CBC3GDC1 0101-00223-00249-0942-00038-00034-00000-BC0THOR
/*********************************************************************/
/* This example demonstrates arithmetic operations on decimal        */
/* variables. output is written to the SYSPRINT file via the printf  */
/* function.                                                         */
/*********************************************************************/

#include <decimal.h>            /* decimal header file */
#include <stdio.h>

int main(void)
{

decimal(10,2) op_1 = 12d;
decimal(5,5) op_2 = -.12345d;
decimal(24,12) op_3 = 12.34d;
decimal(20,5) op_4 = 11.01d;

decimal(14,5) res_add;
decimal(25,2) res_sub;
decimal(15,7) res_mul;
decimal(31,14) res_div;

res_add = op_1 + op_2;
res_sub = op_3 - op_1;
res_mul = op_2 * op_1;
res_div = op_3 / op_4;

printf("res_add =%D(*,*)\n",digitsof(res_add),
       precisionof(res_add),res_add);
printf("res_sub =%D(*,*)\n",digitsof(res_sub),
       precisionof(res_sub),res_sub);
printf("res_mul =%D(*,*)\n",digitsof(res_mul),
       precisionof(res_mul),res_mul);
printf("res_div =%D(*,*)\n",digitsof(res_div),
       precisionof(res_div), res_div);

return(0);
}
./ ADD NAME=CBC3GDC2 0100-00223-00249-1311-00025-00025-00000-BC0THOR

/* this example shows how to use a relational expression with the */
/* decimal data type */

#include <decimal.h>

decimal(10,3) pdval = 0000023.423d;    /* Decimal declaration*/
int ival = 1233;                       /* Integer declaration*/
float fval = 1234.34;                  /* Float declaration*/
double dval = 251.5832;                /* Double declaration*/
long double lval = 37486.234;          /* Long double declaration*/

int main(void)
{
  decimal(15,6) value = 000485860.085999d;
/*Perform relational operation between other data types and decimal*/
  if (pdval < ival) printf("pdval is the smallest !\n");
  if (pdval < fval) printf("pdval is the smallest !\n");
  if (pdval < dval) printf("pdval is the smallest !\n");
  if (pdval < lval) printf("pdval is the smallest !\n");
  if (pdval < value) printf("pdval is the smallest !\n");

  return(0);
}

./ ADD NAME=CBC3GDC3 0100-00223-00249-1338-00085-00085-00000-BC0THOR
/* this example demonstrates the use of the decimal data type */
/* always include decimal.h when decimal data type is used */

#include <decimal.h>

/* Declares a decimal(10,2) variable */
decimal(10,2) pd01;

/* Declares a decimal(15,4) variable and initializes it with the */
/* value 1234.56d                                                */
decimal(15,4) pd02 = 1234.56d;

/* Structure that has decimal related members */
struct pdec
  {                             /* members' data types        */
  int m;                        /* - integer                  */
  decimal(23,10) pd03;          /* - decimal(23,10)           */
  decimal(10,2) pd04[3];        /* - array of decimal(10,2)   */
  decimal(10,2) *pd05;          /* - pointer to decimal(10,2) */
  } pd06,
   *pd07 = &pd06;              /* pd07 points to pd06        */

/* Array of decimal(31,30) */
decimal(31,30) pd08[2];

/* Prototype for function that accepts decimal(10,2) and int as */
/* arguments and has return type decimal(25,5)                  */
decimal(25,5) product(decimal(10,2), int);

decimal(5,2) PdCnt;             /* decimal loop counter */
int i;

int main(void)
{
  pd01 = -789.45d;              /* simple assignment */
  pd06.m = digitsof(pd06.pd03) + precisionof(pd02);  /* 23 + 4 */
  pd06.pd03 = sizeof(pd01);
  pd06.pd04[0] = pd02 + pd01;   /* decimal addition */
  *(pd06.pd04 + 1) = (decimal(10,2)) product(pd07->pd04[0], pd07->m);
  pd07->pd04[2] = product(pd07->pd04[0], pd07->pd04[1]);
  pd07->pd05 = &pd01;           /* taking the address of a */
                                /*   decimal variable      */
  /* These two statements are different */
  pd08[0] = 1 / 3d;
  pd08[1] = 1d / 3d;

  printf("pd01 = %D(10,2)\n", pd01);
  printf("pd02 = %*.*D(*,*)\n",
          20, 5, digitsof(pd02), precisionof(pd02), pd02);
  printf("pd06.m = %d, pd07->m = %d\n", pd06.m, pd07->m);
  printf("pd06.pd03 = %D(23,10), pd07->pd03 = %D(23,10)\n",
          pd06.pd03, pd07->pd03);

  /* You will get an infinite loop if floating type is  */
  /* used instead of the decimal data types.            */
  for (PdCnt = 0.0d; PdCnt != 3.6d; PdCnt += 1.2d)
  {
    i = PdCnt / 1.2d;
    printf("pd06.pd04[%d] = %D(10,2), \
            pd07->pd04[%d] = %D(10,2)\n",
            i, pd06.pd04[i], i, pd07->pd04[i]);
  }

  printf("*(pd06.pd05) = %D(10,2), *(pd07->pd05) = %D(10,2)\n",
          *(pd06.pd05), *(pd07->pd05));

  printf("pd08[0] = %D(31,30)\n", pd08[0]);
  printf("pd08[1] = %D(31,30)\n", pd08[1]);

  return(0);
}

/* Function definition for product() */
decimal(25,5) product(decimal(10,2) v1, int v2)
{

  /* The following happens in the return statement */
  /* - v2 is converted to decimal(10,0)                          */
  /* - after the multiplication, the expression has resulting    */
  /*   type decimal(20,2) (i.e. (10,2) * (10,0) ==> (20,2))      */
  /* - the result is then converted implicitly to decimal(25,5)  */
  /*   before it is returned                                     */
  return( v1 * v2 );

}
./ ADD NAME=CBC3GDC4 0100-00223-00355-1206-00023-00023-00000-BC0THOR
/* this example demonstrates the use of the decimal data type */

#include <decimal.h>

decimal(31,4) pd01 = 1234.5678d;
decimal(29,4) pd02 = 1234.5678d;

int main(void)
{
  /* The results are different in the next two statements */
  pd01 = pd01 + 1d;
  pd02 = pd02 + 1d;

  printf("pd01 = %D(31,4)\n", pd01);
  printf("pd02 = %D(29,4)\n", pd02);

  /* Warning: The decimal variable with size 31 should not be      */
  /*          used in arithmetic operation.                        */
  /*          In the above example: (31,4) + (1,0) ==> (31,3)      */
  /*                                (29,4) + (1,0) ==> (30,4)      */

  return(0);
}
./ ADD NAME=CBC3GDI1 0102-00223-00277-1834-00037-00037-00000-BC0THOR
/* this example demonstrates how to print the __amrc structure */

#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>

int main(void) {
   FILE *fp;
   __amrc_type save_amrc;
   char buffer[80];
   int i = 0;

   /* open an MVS binary file */

   fp = fopen("'test.cbc3gdi1'","wb, recfm=F, lrecl=80");
   if (fp == NULL) exit(99);

   memset(buffer, 'A', 80);

   /* write to MVS file until it runs out of extents */

   while (fwrite(buffer, 1, 80, fp) == 80)
      ++i;

   save_amrc = *__amrc;  /* need copy of __amrc structure */

   printf("number of successful fwrites of 80 bytes = %d\n", i);

   printf("last fwrite errno=%d lastop=%d syscode=%X rc=%d\n",
           errno,
           save_amrc.__last_op,
           save_amrc.__code.__abend.__syscode,
           save_amrc.__code.__abend.__rc);

   return 0;
}
./ ADD NAME=CBC3GDI2 0102-00223-00277-1831-00063-00063-00000-BC0THOR
/* this example demonstrates how to use SIGIOERR */

#include <stdio.h>
#include <signal.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>

#ifdef __cplusplus
    extern "C" {
#endif

void iohdlr(int);

#ifdef __cplusplus
    }
#endif

int main(void) {
   FILE *fp;
   char buffer[80];
   int i = 0;

   signal(SIGIOERR, iohdlr);

   /* open an MVS binary file */

   fp = fopen("'test.cbc3gdi1'","wb, recfm=F, lrecl=80");
   if (fp == NULL) exit(99);

   memset(buffer, 'A', 80);

   /* write to MVS file until it runs out of extents */

   while (fwrite(buffer, 1, 80, fp) == 80)
      ++i;

   printf("number of successful fwrites of 80 bytes = %d\n", i);

   return 0;
}
void iohdlr (int signum) {
   __amrc_type save_amrc;
   __amrc2_type save_amrc2;
   char filename[FILENAME_MAX];
   fldata_t info;

   save_amrc = *__amrc;    /* need copy of __amrc structure  */
   save_amrc2 = *__amrc2;  /* need copy of __amrc2 structure */

   /* get name of file causing error from fldata */

   if (fldata(save_amrc2.__fileptr, filename, &info) == 0)
      printf("error on file %s\n",filename);

   perror("io handler");  /* give errno message */
   printf("lastop=%d syscode=%X rc=%d\n",
           save_amrc.__last_op,
           save_amrc.__code.__abend.__syscode,
           save_amrc.__code.__abend.__rc);

   signal(SIGIOERR, iohdlr);
}
./ ADD NAME=CBC3GDLI 0100-00223-00249-1447-00019-00019-00000-BC0THOR
/* this example shows how to determine whether the SAA C or POSIX */
/* locale is in effect */

#include <stdio.h>
#include <ctype.h>

int main(void)
{
    if (ispunct(0x4A)) {
        printf(" cent sign is punct\n");
        printf(" current locale is SAA- or S370-like\n");
    }
    else {
        printf(" cent sign is not punct\n");
        printf(" default locale is POSIX-like\n");
    }

return(0);
}
./ ADD NAME=CBC3GDW1 0100-00223-00249-1454-00025-00025-00000-BC0THOR
/* this example shows how DWS may be used with C */

int main(void)
{
  /* Set up the parameters that will be used by CSRIDAC.  */

  char op_type[5]      = "BEGIN";
  char object_type[9]  = "TEMPSPACE";
  char object_name[45] = "DWS.FILE ";
  char scroll_area[3]  = "YES";
  char object_state[3] = "NEW";
  char access_mode[6]  = "UPDATE";
  long int object_size = 8;
  char object_id[8];
  long int high_offset, return_code, reason_code;

  /* Access a DWS TEMPSPACE data object.                  */

  csridac(op_type, object_type, object_name, scroll_area, object_state,
          access_mode,&object_size,&object_id,&high_offset,&return_code,
          &reason_code);
/* INSERT ADDITIONAL CODE HERE */

  return(0);
}
./ ADD NAME=CBC3GEV1 0100-00223-00249-1456-00031-00031-00000-BC0THOR
/* this example shows how environment variables are propagated */
/* part 1 of 2-other file is CBC3GEV2 */

#include <stdio.h>
#include <stdlib.h>

int main(void) {

   char *x;

   /*   set the environment variable _EDC_ANSI_OPEN_DEFAULT   */
   setenv("_EDC_ANSI_OPEN_DEFAULT","Y",1);

   /*   set x to the current value of _EDC_ANSI_OPEN_DEFAULT   */
   x = getenv("_EDC_ANSI_OPEN_DEFAULT");

   printf("cbc3gev1 _EDC_ANSI_OPEN_DEFAULT = %s\n",
      (x != NULL) ? x : "undefined");

   /*   call the child program   */
   system("cbc3gev2");

   /*   set x to the current value of _EDC_ANSI_OPEN_DEFAULT   */
   x = getenv("_EDC_ANSI_OPEN_DEFAULT");

   printf("cbc3gev1 _EDC_ANSI_OPEN_DEFAULT = %s\n",
      (x != NULL) ? x : "undefined");

   return(0);
}

./ ADD NAME=CBC3GEV2 0100-00223-00249-1455-00026-00026-00000-BC0THOR
/* this example shows how environment variables are propagated */
/* part 2 of 2-other file is CBC3GEV1 */

#include <stdio.h>
#include <stdlib.h>

int main(void) {

   char *x;

   /*   set x to the current value of _EDC_ANSI_OPEN_DEFAULT   */
   x = getenv("_EDC_ANSI_OPEN_DEFAULT");

   printf("cbc3gev2 _EDC_ANSI_OPEN_DEFAULT = %s\n",
      (x != NULL) ? x : "undefined");

   /*   clear the Environment Variables Table   */
   clearenv();

   /*   set x to the current value of  _EDC_ANSI_OPEN_DEFAULT   */
   x = getenv("_EDC_ANSI_OPEN_DEFAULT");
   printf("cbc3gev2 _EDC_ANSI_OPEN_DEFAULT = %s\n",
      (x != NULL) ? x : "undefined");

   return(0);
}
./ ADD NAME=CBC3GHC1 0100-00223-00223-1421-00432-00432-00000-BC0THOR
/*
 * CBC3GHC1: Sample code to convert all C syntax from code page 1047
 *           to the coded character set the user specifies.
 *           Comments, string literals and character constants are
 *           left alone. The escape character in an escape sequence
 *           is changed, since it is variant.
 *
 * Usage: CBC3GHC1 <coded character set>
 *        The input file is read from stdin and the output is written
 *        to stdout.
 *
 * Example: If you want to convert all C syntax, written in coded
 *          character set 1047, in a file (test1047 c a) to coded
 *          character set 500, you can use CBC3GHC1 by issuing
 *          the following command.
 *
 *          cbc3ghc1 <test1047.c.a >test1047.gen.a IBM-500
 *
 *          The result will store in "test500 gen a" file.
 */

#include <stdio.h>
#include <stdlib.h>
#include <iconv.h>
#include <errno.h>

enum boolean   { false=0, False=0, FALSE=0, true=1, True=1, TRUE=1 };

/*
 * CharState - state that the FSM is in. Initial State is CodeState
 */
enum CharState { CodeState, SQuoteState, DQuoteState, CommentState,
                 DBCSState, EscState, EOFState };

/*
 * CharVal - characters that can change the state of the FSM
 */
enum CharVal   { SlashChar='/',        SQuoteChar='\'', DQuoteChar='"',
                 StarChar='*',    SOChar='\x0E',       SIChar='\x0F',
                 BSlashChar='\\', EOFChar= -1 };

/*
 * XlateTable - type of translation table
 */
typedef iconv_t  XlateTable;

static char *Initialize(int argc, char *argv[]);
static int Convert(char *codeset);
static int InitConv(char **inBuff, char **outBuff, int *maxRecSize,
                    char *codeSet, XlateTable *xlateTable);
static void ConvBuff(int start, int end,
                     char *buff, XlateTable xlateTable);
static enum CharVal LookAhead(char *inBuff, char *outBuff,
                              int *recSize, int *curPos,
                              int maxRecSize, int *codeStartPos,
                              enum CharState state,
                              XlateTable xlateTable);
static enum CharVal GetNextChar(char *inBuff, char *outBuff,
                                int *recSize, int maxRecSize,
                                int *curPos, int *codeStartPos,
                                enum CharState state,
                                XlateTable xlateTable);
static int UpdateAndRead(char *inBuff, char *outBuff,
                         int *recSize, int maxRecSize,
                         int codeStartPos, enum CharState state,
                         XlateTable xlateTable);
static int ReadAndCopy(char *inBuff,char *outBuff, int maxRecSize);

#pragma inline(LAST_POS)
#pragma inline(NEXT_TO_LAST_POS)
#pragma inline(LookAhead)
#pragma inline(GetNextChar)
#pragma inline(ConvBuff)

/*
 * Initialize the environment, and if everything is ok, convert input
 */
main(int argc, char *argv[]) {
  char *codeset = Initialize(argc, argv);
  if (codeset == NULL) {
    return(8);
  }
  return(Convert(codeset));
}

/*
 * Check that 1 parameter was specified - the coded character set to convert the
 * the syntax to.
 * Re-open stdin and stdout as binary files for record IO.
 * Return the code set if everything is ok, NULL otherwise
 */
static char *Initialize(int argc, char *argv[]) {
  if (argc != 2) {
    fprintf(stderr, "Expected %d argument but got %d\n",
            1, argc-1);
    return(NULL);
  }
  stdin = freopen("", "rb,type=record", stdin);
  stdout= freopen("", "wb,type=record", stdout);
  if (stdin == NULL || stdout == NULL) {
    fprintf(stderr, "Could not re-open standard streams\n");
    return(NULL);
  }

  return(argv[1]);
}

/*
 * Return the last position in a record
 */
static int LAST_POS(int recSize) {
  return(recSize-1);
}

/*
 * Return the next to last position in a record
 */
static int NEXT_TO_LAST_POS(int recSize) {
  return(recSize-2);
}

/*
 * Convert the stdin file using codeset and write to stdout.
 * Set up the translation table.
 * Read the first record and copy it into the output buffer.
 * Go through the FSM, starting in the Code State and leaving
 * when EOFState is reached (End Of File).
 * Close the translation table.
 */
static int Convert(char *codeset) {
  enum CharVal   c;
  int            recSize;
  enum CharState prvState;
  int            rc;

  int            codeStartPos = 0;
  int            curPos  = 0;
  enum boolean   high    = FALSE;
  enum CharState state   = CodeState;

  char *         inBuff;
  char *         outBuff;
  int            maxRecSize;
  XlateTable     xlateTable;

  rc = InitConv(&inBuff, &outBuff, &maxRecSize, codeset, &xlateTable);
  if (rc) {
    if (inBuff)  free(inBuff);
    if (outBuff) free(outBuff);
    return(rc);
  }

  recSize = ReadAndCopy(inBuff, outBuff, maxRecSize);

  while (state != EOFState) {
    c = GetNextChar(inBuff, outBuff, &recSize, maxRecSize,
                    &curPos, &codeStartPos, state, xlateTable);
    if (c == EOFChar) {
      state = EOFState;
    }

    switch(state) {
      case CodeState:
        switch (c) {
          case BSlashChar:
            curPos = LAST_POS(recSize);
            break;
          case SlashChar:
            if (LookAhead(inBuff, outBuff, &recSize,
                          &curPos, maxRecSize, &codeStartPos,
                          state, xlateTable)
                          == StarChar) {
              state = CommentState;
            }
            break;
          case SQuoteChar:
            state = SQuoteState;
            break;
          case DQuoteChar:
            state = DQuoteState;
            break;
        }
        if (state != CodeState || curPos == NEXT_TO_LAST_POS(recSize)) {
          if (curPos == NEXT_TO_LAST_POS(recSize)) {
            ++curPos;
          }
          else {
            ConvBuff(codeStartPos, curPos, outBuff, xlateTable);
          }
        }
        break;

      case CommentState:
        switch(c) {
          case BSlashChar:
            curPos = LAST_POS(recSize);
            break;
          case StarChar:
            if (LookAhead(inBuff, outBuff, &recSize,
                          &curPos, maxRecSize, &codeStartPos,
                          state, xlateTable)
                          == SlashChar) {
              state = CodeState;
              codeStartPos = curPos;
            }
            break;
        }
        break;

      case DQuoteState:
        switch(c) {
          case DQuoteChar:
            state = CodeState;
            codeStartPos = curPos;
            break;
          case SOChar:
            prvState = state;
            state    = DBCSState;
            break;
          case BSlashChar:
            ConvBuff(curPos, curPos, outBuff, xlateTable);
            if (curPos != LAST_POS(recSize)) {
              prvState = state;
              state = EscState;
            }
            break;
        }
        break;

      case SQuoteState:
        switch(c) {
          case SQuoteChar:
            state = CodeState;
            codeStartPos = curPos;
            break;
          case SOChar:
            prvState = state;
            state    = DBCSState;
            break;
          case BSlashChar:
            ConvBuff(curPos, curPos, outBuff, xlateTable);
            if (curPos != LAST_POS(recSize)) {
              prvState = state;
              state = EscState;
            }
            break;
        }
        break;

      case DBCSState:
        high ¬= 1;  /* TRUE -> FALSE or FALSE -> TRUE */
        if (high && (c == SIChar)) {
          state = prvState;
          high  = FALSE;
        }
        break;

      case EscState:
        state = prvState; /* really, this is ok */
        break;

      case EOFState:
        break;

      default:
        fprintf(stderr, "Internal error - ended up in state %d\n",
                state);
        return(16);

    } /* end of switch statement */
    ++curPos;
  }
  rc = TermConv(inBuff, outBuff, xlateTable);
  return(0);
}

/*
 * Initialize the translation table and allocate the input and
 * output buffers to use.
 * Return 0 if successful.
 */
static int InitConv(char **inBuff, char **outBuff, int *maxRecSize,
                    char *codeset, XlateTable* xlateTable) {

  static char fileNameBuff[FILENAME_MAX+1];
  fldata_t info;
  int rc;

  *outBuff = *inBuff = NULL;

  rc = fldata(stdin, fileNameBuff, &info);
  if (rc) {
    return(rc);
  }

  *maxRecSize = info.__maxreclen;
  *inBuff     = malloc(*maxRecSize);
  *outBuff    = malloc(*maxRecSize);

 if ((*xlateTable = iconv_open("IBM-1047",codeset)) == (iconv_t)(-1)) {
    fprintf(stderr,"Cannot open convertor from %s to IBM-1047",codeset);
     return (8);
  }

  return(!inBuff || !outBuff);
}

/*
 * Convert the buffer from start to end using the translation table
 */
static void ConvBuff(int start, int end,
                     char *buff, XlateTable xlateTable) {
   int rc;
   size_t inleft, outleft, org;
   char *inptr, *outptr;

   outleft = inleft = end-start+1;
   inptr = outptr = &buff[start];

   while (1) {
     rc = iconv(xlateTable,&inptr,&inleft,&outptr,&outleft);

     if (rc == -1) {
       switch (errno) {
                       /* Skip the invalid character */
        case EILSEQ:  if (--inleft == 0) return;
                       ++inptr;
                       ++outptr;
                       --outleft;
                       break;

       default: fprintf(stderr,"iconv() fails with errno = %d\n",errno);
                 exit(8);
         }
     } else
       return;
   }
}

/*
 * Look ahead to the next character. If the current position
 * is the last character of the input record, write the current
 * output record and read in the next record.
 * Return the 'character' read, which may be EOF if the end of
 * the file was reached.
 */
static enum CharVal LookAhead(char *inBuff, char *outBuff,
                              int *recSize, int *curPos,
                              int maxRecSize, int *codeStartPos,
                              enum CharState state,
                              XlateTable xlateTable) {

  if (*curPos == LAST_POS(*recSize)) {
    if (UpdateAndRead(inBuff, outBuff, recSize, maxRecSize,
                      *codeStartPos, state, xlateTable)) {
      return(EOFChar);
    }
    *curPos = 0;
    *codeStartPos = 0;
  }
  else {
    (*curPos)++;
  }
  return(inBuff[*curPos]);
}

/*
 * Similar to LookAhead(), but return the current character
 */
static enum CharVal GetNextChar(char *inBuff, char *outBuff,
                                int *recSize, int maxRecSize,
                                int *curPos, int *codeStartPos,
                                enum CharState state,
                                XlateTable xlateTable) {

  if (*curPos > LAST_POS(*recSize)) {
    if (UpdateAndRead(inBuff, outBuff, recSize, maxRecSize,
                      *codeStartPos, state, xlateTable)) {
      return(EOFChar);
    }
    *curPos = 0;
    *codeStartPos = 0;
  }
  return(inBuff[*curPos]);
}

/*
 * If the current state is the code state, translate the remaining
 * part of the record.
 * Write out the record to stdout
 * Read in the next record and copy it to the output buffer.
 */
static int UpdateAndRead(char *inBuff, char *outBuff,
                         int *recSize, int maxRecSize,
                         int codeStartPos, enum CharState state,
                         XlateTable xlateTable) {

  if (state == CodeState) {
    ConvBuff(codeStartPos, LAST_POS(*recSize), outBuff, xlateTable);
  }
  fwrite(outBuff, 1, *recSize, stdout);
  *recSize = ReadAndCopy(inBuff, outBuff, maxRecSize);
  return((*recSize == 0) ? 1 : 0);
}

/*
 * Read in a record from stdin and copy it to the output buffer.
 * Return the number of bytes read.
 */
static int ReadAndCopy(char *inBuff, char *outBuff, int maxRecSize) {
  int recSize;

  recSize = fread(inBuff, 1, maxRecSize, stdin);
  if (feof(stdin) && recSize == 0) {
    return(0);
  }
  else {
    memcpy(outBuff, inBuff, recSize);
    return(recSize);
  }
}

/*
 * Free allocated storage and close the translation table.
 */
static int TermConv(char *inBuff,
                    char *outBuff, XlateTable xlateTable) {
  iconv_close(xlateTable);
  free(inBuff);
  free(outBuff);
  return(0);
}
./ ADD NAME=CBC3GHF1 0100-00223-00249-1636-00041-00041-00000-BC0THOR
/* this example shows how unnamed pipes may be used */

#include <unistd.h>
#include <stdio.h>
#include <errno.h>

int main() {
int ret_val;
int pfd[2];
char buff[32];
char string1[]="String for pipe I/O";

ret_val = pipe(pfd);                 /* Create pipe */
if (ret_val != 0) {             /* Test for success */
  printf("Unable to create a pipe; errno=%d\n",errno);

  exit(1);                         /* Print error message and exit */
}

if (fork() == 0) {
   /* child program */
   close(pfd[0]); /* close the read end */
   ret_val = write(pfd[1],string1,strlen(string1)); /*Write to pipe*/
   if (ret_val != strlen(string1)) {
      printf("Write did not return expected value\n");
      exit(2);                       /* Print error message and exit */
   }
}
else {
   /* parent program */
   close(pfd[1]); /* close the write end of pipe */
   ret_val = read(pfd[0],buff,strlen(string1)); /* Read from pipe */
   if (ret_val != strlen(string1)) {
      printf("Read did not return expected value\n");
      exit(3);                       /* Print error message and exit */
   }
   printf("parent read %s from the child program\n",buff);

}
exit(0);
}
./ ADD NAME=CBC3GHF2 0101-00223-00252-0901-00122-00118-00000-BC0THOR
/* this example shows how named pipes may be used */

 #define _POSIX_SOURCE
 #include <sys/stat.h>
 #include <stdlib.h>
 #include <string.h>
 #include <stdio.h>
 #include <unistd.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <wait.h>

/*                                                                *
 *   Sample use of mkfifo()                                       *
 *                                                                */

main()

{                                    /* start of program          */

 int     flags, ret_value, c_status;
 pid_t   pid;
 size_t  n_elements;
 char    char_ptr[32];
 char    str[] = "string for fifo ";
 char    fifoname[] = "temp.fifo";
 FILE    *rd_stream,*wr_stream;

 if ((mkfifo(fifoname,S_IRWXU)) != 0) {
   printf("Unable to create a fifo; errno=%d\n",errno);
   exit(1);                     /* Print error message and return */
 }

 if ((pid = fork()) < 0) {
    perror("fork failed");
    exit(2);
 }

 if (pid == (pid_t)0) {        /* CHILD process                  */
    /* issue fopen for write end of the fifo                     */
        wr_stream = fopen(fifoname,"w");
           if (wr_stream == (FILE *) NULL)  {
              printf("In child process\n");
              printf("fopen returned a NULL, expected valid stream\n");
              exit(100);
           }

        /* perform a write                                        */
        n_elements = fwrite(str,1,strlen(str),wr_stream);
           if (n_elements != (size_t) strlen(str)) {
             printf("Fwrite returned %d, expected %d\n",
                (int)n_elements,strlen(str));
             exit(101);
            }
      exit(0);                 /* return success to parent        */
    }
    else  {                    /* PARENT  process                 */

        /* issue fopen for read                                   */
        rd_stream = fopen(fifoname,"r");
        if (rd_stream == (FILE *) NULL)  {
           printf("In parent process\n");
           printf("fopen returned a NULL, expected valid pointer\n");
           exit(2);
        }

        /* get current flag settings of file                      */
        if ((flags = fcntl(fileno(rd_stream),F_GETFL)) == -1) {
           printf("fcntl returned -1 for %s\n",fifoname);
           exit(3);
        }

        /* clear O_NONBLOCK  and reset file flags                 */
        flags &= ~(O_NONBLOCK);
        if ((fcntl(fileno(rd_stream),F_SETFL,flags)) == -1) {
           printf("\nfcntl returned -1 for %s",fifoname);
           exit(4);
        }

             /* try to read the string                              */
        ret_value = fread(char_ptr,sizeof(char),strlen(str),rd_stream);
        if (ret_value != strlen(str)) {
           printf("\nFread did not read %d elements as expected ",
              strlen(str));
           printf("\nret_value is %d ",ret_value);
           exit(6);
        }

        if (strncmp(char_ptr,str,strlen(str))) {
           printf("\ncontents of char_ptr are %s ",
              char_ptr);
           printf("\ncontents of str are %s ",
              str);
           printf("\nThese should be equal");
           exit(7);
        }

        ret_value = fclose(rd_stream);
        if (ret_value != 0)  {
            printf("\nFclose failed for %s",fifoname);
            printf("\nerrno is %d",errno);
            exit(8);
        }

        ret_value = remove(fifoname);
        if (ret_value != 0)  {
            printf("\nremove failed for %s",fifoname);
            printf("\nerrno is %d",errno);
            exit(9);
        }

      pid = wait(&c_status);
      if ((WIFEXITED(c_status) !=0) && (WEXITSTATUS(c_status) !=0)) {
        printf("\nchild exited with code %d",WEXITSTATUS(c_status));
        exit(10);
      }
    }   /* end of else clause                                       */
    printf("About to issue exit(0),  \
processing completed successfully\n");
    exit(0);

}
./ ADD NAME=CBC3GHF3 0102-00223-00277-1816-00111-00111-00000-BC0THOR
/* this example uses HFS stream I/O */

#define _OPEN_SYS
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <sys/types.h>
#undef _OPEN_SYS
FILE *stream;

char string1[] = "A line of text.";   /* NOTE: There are actually 16 */
char string2[] = "Find this line.";   /*   characters in each line of */
char string3[] = "Another stream.";   /*   text.  The 16th is a null  */
char string4[16];                     /*   terminator on each string. */
long position, strpos;                /*   Since the null character   */
int i, result, fd;                    /*   is not being written to    */
int rc;                               /*   the file, 15 is used as    */
                                      /*   the data stream length.    */
ssize_t x;
char buffer[16];

int main(void)
{

   /* Write continuous streams to file  */

   if ((stream = fopen("./'test.cbc3ghf3.stream'","wb"))==NULL) {
         perror("Error opening file");
         exit(0);
   }

   for(i=0; i<12;i++) {
      int len1 = strlen(string1);
      rc = fwrite(string1, 1, len1, stream);
      if (rc != len1) {
         perror("fwrite failed");
         printf("i = %d\n", i);
         exit(99);
      }
   }
   rc = fwrite(string2,1,sizeof(string2)-1,stream);

   if (rc != sizeof(string2)-1) {
      perror("fwrite failed");
      exit(99);
   }

   for(i=0;i<12;i++) {
      rc = fwrite(string1,1,sizeof(string1)-1,stream);

      if (rc != sizeof(string1)-1) {
         perror("fwrite failed");
         printf("i = %d\n", i);
         exit(99);
      }
   }
   fclose(stream);

   /* Read data stream and search for location of string2.        */
   /* EOF is not set until an attempt is made to read past the    */
   /* end-of-file, thus the fread is at the end of the while loop */

   stream = fopen("./'test.cbc3ghf3.stream'", "rb");

   if ((position = ftell(stream)) == -1L)
      perror("Error saving file position.");

   rc = fread(string4, 1, sizeof(string2)-1, stream);

   while(!feof(stream)) {
      if (rc != sizeof(string2)-1) {
         perror("fread failed");
         exit(99);
      }

      if (strstr(string4,string2) != NULL)   /* If string2 is found */
         strpos = position ;                 /* then save position. */

      if ((position=ftell(stream)) == -1L)
         perror("Error saving file position.");

      rc = fread(string4, 1, sizeof(string2)-1, stream);
   }

   fclose(stream);
   /* Replace line containing string2 with string3 */

   fd = open("'test.cbc3ghf3.data'",O_RDWR);

   if (fd < 0){
     perror("open failed\n");
   }

   x = write(fd,"a record",8);

   if (x < 8){
     perror("write failed\n");
   }

   rc = lseek(fd,0,SEEK_SET);
   x = read(fd,buffer,8);

   if (x < 8){
     perror("read failed\n");
   }
   printf("data read is %.8s\n",buffer);

   close(fd);
}
./ ADD NAME=CBC3GIPX 0100-00264-00264-1045-00048-00048-00000-BC0THOR
/*********************************************************************/
/* This is a main program to call CBC3GIP1, which reads the          */
/* directory of the PDS whose name is sent to it and returns a       */
/* pointer to a linked list of member names.                         */
/*                                                                   */
/* The pds_mem() function called here is included in the source      */
/* for CBC3GIP1. In addition, the header file CBC3GIP2 is required   */
/* by both programs. To prepare the executable, first compile/link   */
/* CBC3GIP0 and CBC3GIP1 into a load library, then add a bind step   */
/* to build the executable that has a MYLIB DD statement for the     */
/* library containing these load modules, and in the SYSLIN file:    */
/*   INCLUDE MYLIB(CBC3GIP0)                                         */
/*   INCLUDE MYLIB(CBC3GIP1)                                         */
/*   ENTRY CEESTART                                                  */
/*   NAME CBC3GIP0(R)                                                */
/*                                                                   */
/* Author R thornton Sep 2000                                        */
/*********************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
/*  #include "cbc3gip2.h"   */
#define NAMELEN 8
struct node {
             struct node *next;
             char name[NAMELEN+1];
            } *el_ptr;
struct node* pds_mem(const char *pds);

/*********************************************************************/
/* main program calls the pds_mem sub program to get a list of       */
/* member names for the pds, then prints them via printf()           */
/*********************************************************************/
int main(void) {

  el_ptr = pds_mem("bc0thor.pds.jcl");
  if(el_ptr == NULL) {
    printf("\nNo data returned by pds_mem");
    exit(1);
  }

  while(el_ptr != NULL) {
    printf("\n%s",el_ptr->name);     /* print a member name */
    el_ptr = el_ptr->next;           /* step to next element */
  }

}
./ ADD NAME=CBC3GIP0 0106-00263-00277-1808-00045-00227-00000-BC0THOR
/*********************************************************************/
/* This is a main program to call CBC3GIP1, which reads the          */
/* directory of the PDS whose name is sent to it and returns a       */
/* pointer to a linked list of member names.                         */
/*                                                                   */
/* As written, the dataset name for the PDS whose directory is read  */
/* is given as CBC.TRIGON.SAMPSRC. If a different PDS is to be used, */
/* change line 36 to show the desired dataset name.                  */
/*                                                                   */
/* The pds_mem() function called here is included in the source      */
/* for CBC3GIP1. In addition, the header file CBC3GIP2 is required   */
/* by both programs. To prepare the executable, first compile/link   */
/* CBC3GIP1 with NCAL into a load library as CBC3GIP1, then compile  */
/* and bind CBC3GIP0 with the following bind control statements:     */
/*   INCLUDE MYLIB(CBC3GIP1)                                         */
/*   ENTRY CEESTART                                                  */
/*   NAME CBC3GIP0(R)                                                */
/*                                                                   */
/* Author R Thornton Sep 2000                                        */
/*********************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "cbc3gip2.h"

/*********************************************************************/
/* main program calls the pds_mem sub program to get a list of       */
/* member names for the pds, then prints them via printf()           */
/*********************************************************************/
int main(void) {
  struct node *ptr;

  ptr = pds_mem("cbc.trigon.sampsrc");
  if(ptr == NULL) {
    printf("\nNo data returned by pds_mem");
    exit(1);
  }

  while(ptr != NULL) {
    printf("\n%s",ptr->name);        /* print a member name */
    ptr = ptr->next;                 /* step to next element */
  }
  exit(0);
}
./ ADD NAME=CBC3GIP1 0105-00223-00264-1035-00232-00220-00000-BC0THOR
/*********************************************************************/
/* This example shows how to create a list of members of a PDS under */
/* MVS.                                                              */
/* part 1 of 2-other file is CBC3GIP2 (a header file in cbc.scbcsam) */
/*                                                                   */
/* NOTE: The main() function was not included in the original code   */
/*       and was written separately as CBC3GIP0, which calls the     */
/*       pds_mem() function here to obtain the linked list of        */
/*       member names. See source for CBC3GIP0 for linkedit details. */
/*                                                                   */
/* NODE_PTR pds_mem(const char *pds):                                */
/* pds must be a fully qualified pds name, eg ID.PDS.DATASET returns */
/* a pointer to a linked list of nodes.  Each node contains a member */
/* of the pds and a pointer to the next node.  If no members exist,  */
/* the pointer is NULL.                                              */
/*                                                                   */
/* Note: Behavior is undefined if pds is the name of a sequential    */
/*       file.                                                       */
/*********************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "cbc3gip2.h"

/*********************************************************************/
/* RECORD: each record of a pds will be read into one of these       */
/*         structures. The first two bytes is the record length,     */
/*         which is put into 'count', the remaining 254 bytes are    */
/*         put into rest.  Each record is 256 bytes long.            */
/*********************************************************************/

#define RECLEN  254

typedef struct {
                unsigned short int count;
                char rest[RECLEN];
               } RECORD;

/*********************************************************************/
/* Local function prototypes                                         */
/*********************************************************************/

static int gen_node(NODE_PTR *node, RECORD *rec, NODE_PTR *last_ptr);
static char *add_name(NODE_PTR *node, char *name, NODE_PTR *last_ptr);

NODE_PTR pds_mem(const char *pds) {

  FILE *fp;
  int bytes;
  NODE_PTR node, last_ptr;
  RECORD rec;
  int list_end;
  char *qual_pds;

  node = NULL;
  last_ptr = NULL;
/*********************************************************************/
/* Allocate a new variable, qual_pds, which will be the same as pds, */
/* except with single quotes around it, i.e. ID.PDS.DATASET ==>      */
/* 'ID.PDS.DATA SET'                                                 */
/*********************************************************************/

  qual_pds = (char *)malloc(strlen(pds) + 3);
  if (qual_pds == NULL) {
    fprintf(stderr,"malloc failed for %d bytes\n",strlen(pds) + 3);
    exit(-1);
  }
  sprintf(qual_pds,"'%s'",pds);

/*********************************************************************/
/* Open the pds in binary read mode.  The PDS directory will be read */
/* one record at a time until either the end of the directory or     */
/* end-of-file is detected.  Call up gen_node() with every record    */
/* read, to add member names to the linked list.                     */
/*********************************************************************/

  fp = fopen(qual_pds,"rb");
  if (fp == NULL)
    return(NULL);

  do {
    bytes = fread(&rec, 1, sizeof(rec), fp);
    if ((bytes != sizeof(rec)) && !feof(fp)) {
      perror("FREAD:");
      fprintf(stderr,"Failed in %s, line %d\n"
             "Expected to read %d bytes but read %d bytes\n",
              __FILE__,__LINE__,sizeof(rec), bytes);
      exit(-1);
    }

    list_end = gen_node(&node,&rec, &last_ptr);

  } while (!feof(fp) && !list_end);
  fclose(fp);
  free(qual_pds);
  return(node);
}
/*********************************************************************/
/* GEN_NODE() processes the record passed.  The main loop scans thru */
/* the record until it has read at least rec->count bytes, or a      */
/* directory end marker is detected.                                 */
/*                                                                   */
/* Each record has the form:                                         */
/*                                                                   */
/* +------------+------+------+------+------+----------------+       */
/* + # of bytes |Member|Member|......|Member|  Unused        +       */
/* + in record  |  1   |  2   |      |  n   |                +       */
/* +------------+------+------+------+------+----------------+       */
/*  |--count---||-----------------rest-----------------------|       */
/*  (Note that the number stored in count includes its own           */
/*   two bytes)                                                      */
/*                                                                   */
/* And, each member has the form:                                    */
/*                                                                   */
/* +--------+-------+----+-----------------------------------+       */
/* + Member |TTR    |info|                                   +       */
/* + Name   |       |byte|  User Data TTRN's (halfwords)     +       */
/* + 8 bytes|3 bytes|    |                                   +       */
/* +--------+-------+----+-----------------------------------+       */
/*********************************************************************/

#define TTRLEN 3      /* The TTR's are 3 bytes long */
/*********************************************************************/
/* bit 0 of the info-byte is '1' if the member is an alias,          */
/* 0 otherwise. ALIAS_MASK is used to extract this information       */
/*********************************************************************/
#define ALIAS_MASK ((unsigned int) 0x80)
/*********************************************************************/
/* The number of user data half-words is in bits 3-7 of the info     */
/* byte. SKIP_MASK is used to extract this information.  Since this  */
/* number is in half-words, it needs to be double to obtain the      */
/* number of bytes.                                                  */
/*********************************************************************/
#define SKIP_MASK ((unsigned int) 0x1F)

/*********************************************************************/
/* 8 hex FF's mark the end of the directory.                         */
/*********************************************************************/
char *endmark = "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF";
static int gen_node(NODE_PTR *node, RECORD *rec, NODE_PTR *last_ptr) {

   char *ptr, *name;
   int skip, count = 2;
   unsigned int info_byte, alias, ttrn;
   char ttr[TTRLEN];
   int list_end = 0;

   ptr = rec->rest;

   while(count < rec->count) {
     if (!memcmp(ptr,endmark,NAMELEN)) {
       list_end = 1;
       break;
     }

     /* member name */
     name = ptr;
     ptr += NAMELEN;

     /* ttr */
     memcpy(ttr,ptr,TTRLEN);
     ptr += TTRLEN;

     /* info_byte */
     info_byte = (unsigned int) (*ptr);
     alias = info_byte & ALIAS_MASK;
     if (!alias) add_name(node,name,last_ptr);
     skip = (info_byte & SKIP_MASK) * 2 + 1;
     ptr += skip;
     count += (TTRLEN + NAMELEN + skip);
   }
   return(list_end);
}
/*********************************************************************/
/* ADD_NAME: Add a new member name to the linked node. The new member*/
/* is added to the end so that the original ordering is maintained.  */
/*********************************************************************/

static char *add_name(NODE_PTR *node, char *name, NODE_PTR *last_ptr) {

  NODE_PTR newnode;

/*********************************************************************/
/* malloc space for the new node                                     */
/*********************************************************************/

  newnode = (NODE_PTR)malloc(sizeof(NODE));
  if (newnode == NULL) {
    fprintf(stderr,"malloc failed for %d bytes\n",sizeof(NODE));
    exit(-1);
  }

/*********************************************************************/
/* copy the name into the node and NULL terminate it                 */
/*********************************************************************/

  memcpy(newnode->name,name,NAMELEN);
  newnode->name[NAMELEN] = '\0';
  newnode->next = NULL;

/*********************************************************************/
/* add the new node to the linked list                               */
/*********************************************************************/

  if (*last_ptr != NULL) {
    (*last_ptr)->next = newnode;
    *last_ptr = newnode;
  }
  else {
    *node = newnode;
    *last_ptr = newnode;
  }
  return(newnode->name);
}
/*********************************************************************/
/* FREE_MEM: This function is not used by pds_mem(), but it should be*/
/* used as soon as you are finished using the linked list.  It frees */
/* the storage allocated by the linked list.                         */
/*********************************************************************/

void free_mem(NODE_PTR node) {

  NODE_PTR next_node=node;

  while (next_node != NULL) {
     next_node = node->next;
     free(node);
     node = next_node;
  }
  return;
}
./ ADD NAME=CBC3GIP2 0100-00263-00263-1436-00019-00019-00000-BC0THOR
/* this example shows how to create a list of members of a PDS under */
/* MVS */
/* part 2 of 2-other file is CBC3GIP1 */
/*
 * NODE: a pointer to this structure is returned from the call to pds_mem().
 * It is a linked list of character arrays - each array contains a member
 * name. Each next pointer points * to the next member, except the last
 * next member which points to NULL.
*/

#define NAMELEN 8      /* Length of a MVS member name */

typedef struct node {
                      struct node *next;
                      char nameÝNAMELEN+1¨;
                    } NODE, *NODE_PTR;

NODE_PTR pds_mem(const char *pds);
void free_mem(NODE_PTR list);
./ ADD NAME=CBC3GIS3 0102-00223-00257-1400-00026-00020-00000-BC0THOR
/*********************************************************************/
/* This program shows how to use ISPF with C. It also uses a CLIST   */
/* called CBC3GIS1 and panels CBC3GIS2 and CBC3GIS4. Note that the   */
/* load library containing this program must be available either in  */
/* the LNKLST or via STEPLIB at execution time.                      */
/*********************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#pragma linkage(ISPLINK,OS)

extern ISPLINK() ;

int rc,buflen;
char buffer[20];
int ISPLINK(char[], int, char[]);
int main(void)
{
/* Retrieve the panel definition CBC3GIS4 and display it. */

   strcpy(buffer,"PANEL(CBC3GIS4)");
   buflen = strlen(buffer);
   rc = ISPLINK("SELECT", buflen, buffer);
}
./ ADD NAME=CBC3GIS8 0102-00223-00257-1413-00025-00021-00000-BC0THOR
/*********************************************************************/
/* This program shows how to use ISPF with &cxx., using ISPLINK      */
/*********************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#pragma linkage(ISPLINK,OS)
extern ISPLINK() ;

int rc,buflen;
char buffer[20];
int ISPLINK(char[], int, char[]);

int main(void)
{
/*********************************************************************/
/* Retrieve the panel definition CBC3GIS4 and display it.            */
/*********************************************************************/

   strcpy(buffer,"PANEL(CBC3GIS4)");
   buflen = strlen(buffer);
   rc = ISPLINK("SELECT",buflen, buffer);
}
./ ADD NAME=CBC3GMF1 0103-00224-00257-1740-00068-00026-00000-BC0THOR
/*********************************************************************/
/* This example shows how to remove members of a PDS                 */
/* A number of changes were made to the original to provide a more   */
/* meaningful sample:                                                */
/* 1) type=memory was removed from the fopen() function calls so the */
/*    PDS created could be viewed after job completion.              */
/* 2) Code was rearranged so that the pds is only open for output for*/
/*    one member at a time, as errors resulted when an attempt was   */
/*    made to have the same PDS open for output for two members at   */
/*    the same time.                                                 */
/* 3) Tests were added for successful file open after each fopen()   */
/*    function, and messages were supplied for success or failure    */
/*    of each fopen().                                               */
/* 4) The remove() function call was modified to remove only member  */
/*    mb1, rather than the entire dataset, as was done in the        */
/*    original program, contrary to the program title.               */
/*********************************************************************/

#include <stdio.h>

int main(void)
{
   FILE * fp1, * fp2;
   fp1=fopen("a.b(mbr1)","w");
   if (fp1 == NULL) {
      perror("fopen():");
      printf("\nInitial fopen for mbr1 failed.");
   }
   else {
      printf("\nInitial fopen for mbr1 successful.");
   }
   fwrite("hello, world\n", 1, 13, fp1);
   fclose(fp1);

   fp2=fopen("a.b(mbr2)","w");
   if (fp2 == NULL) {
      perror("fopen():");
      printf("\nInitial fopen for mbr2 failed.");
   }
   else {
      printf("\nInitial fopen for mbr2 successful.");
   }
   fwrite("hello, world\n", 1, 13, fp2);
   fclose(fp2);

   remove("a.b(mbr1)");

   fp1=fopen("a.b(mbr1)","r");
   if (fp1 == NULL) {
      perror("fopen():");
      printf("\nSecond fopen for mbr1 failed as expected: "
             "the file has been removed\n");
   }
   else {
      printf("\nSecond fopen for mbr1 should have failed.");
   }

   fp2=fopen("a.b(mbr2)","r");
   if (fp2 == NULL) {
      perror("fopen():");
      printf("\nSecond fopen for mbr2 failed - should have worked.");
   }
   else {
      printf("\nSecond fopen for mbr2 was successful.");
   }

   return(0);
}
./ ADD NAME=CBC3GMF2 0104-00224-00258-1018-00079-00038-00000-BC0THOR
/*********************************************************************/
/* This example shows how to rename a PDS. it is modified from the   */
/* modified from the original in several ways to provide a better    */
/* example:                                                          */
/* 1) type=memory is removed from the fopen() function calls.        */
/* 2) fopen() and fclose() calls are done to insure the file is only */
/*    opened for output for one member at a time.                    */
/* 3) Tests were added following each open to determine whether or   */
/*    not fopen() was successful, and messages are written either way*/
/* 4) Any former versions of the BC0THOR.A.B and BC0THOR.C.D         */
/*    datasets are deleted to eliminate conflicts.                   */
/*********************************************************************/

#include <stdio.h>

int main(void)
{
   FILE * fp1, * fp2;

   remove("a.b");           /* pre-delete the PDS BC0THOR.A.B */
   remove("c.d");           /* pre-delete the PDS BC0THOR.C.D */

   fp1=fopen("a.b(mbr1)","w"); /* Create PDS BC0THOR.A.B and null */
                               /* member named MBR1 */
   if (fp1 == NULL) {
      perror("Open1:");
      printf("\nOpen1 failed.");
   }
   else {
      printf("\nOpen1 succeeded as expected.");
   }
   fwrite("hello, world1\n", 1, 14, fp1); /* write to member MBR1 */
   fclose(fp1);       /* Close it so we can create another member. */

   fp2=fopen("a.b(mbr2)","w"); /* Open the PDS to create null */
                               /* member named MBR2 */
   if (fp2 == NULL) {
      perror("Open2:");
      printf("\nOpen2 failed.");
   }
   else {
      printf("\nOpen2 succeeded as expected.");
   }
   fwrite("hello, world2\n", 1, 14, fp2);  /* write to member MBR2 */
   fclose(fp2);             /* Close the PDS so we can rename it. */

/*********************************************************************/
/* Rename the PDS from BC0THOR.A.B to BC0THOR.C.D.                   */
/*********************************************************************/
   rename("a.b","c.d");       /* Rename the PDS to BC0THOR.C.D */

/*********************************************************************/
/* After renaming, you must access the dataset by its new name.      */
/*********************************************************************/

   fp1=fopen("a.b(mbr1)","r"); /* Try to open BC0THOR.A.B which was */
                               /* renamed to BC0THOR.C.D */
   if (fp1 == NULL) {
      perror("Open3:");
      printf("\nOpen3 failed as expected, as the PDS was renamed.");
   }
   else {
      printf("\nOpen3 succeeded, but should have failed, as the PDS "
             "has been renamed.");
   }

   fp2=fopen("c.d(mbr1)","r");  /* Now try to open the PDS with its */
                               /* new name BC0THOR.C.D */
   if (fp2 == NULL) {
      perror("\nOpen4:");
      printf("\nOpen4 failed, but should have worked.");
   }
   else {
      printf("\nOpen4 was successful, as expected after the PDS "
             "was renamed.");
   }

   return(0);
}
./ ADD NAME=CBC3GMI2 0105-00224-00264-1315-00438-00431-00000-BC0THOR
/*********************************************************************/
/* debuggable malloc()/calloc()/realloc()/free() example             */
/* part 2 of 2-other file is CBC3GMI1.h                              */
/*                                                                   */
/* This is a set of functions which can be called from another       */
/* program.                                                          */
/*                                                                   */
/* STORAGE:                                                          */
/*                                                                   */
/* EXTERNALS:                                                        */
/*                                                                   */
/*  This file contains code for the following functions:             */
/*   -malloc......allocate storage from a Language Environment heap  */
/*   -calloc......allocate storage from a Language Environement heap */
/*                and initialize it to 0.                            */
/*   -free........free storage previously allocated by malloc in this*/
/*                file.                                              */
/*   -realloc.....re-allocate storage previously allocated by malloc */
/*             in this file. If a NULL pointer is passed instead of a*/
/*                previously allocated pointer, malloc will be called*/
/*                directly.                                          */
/*                                                                   */
/* USAGE:                                                            */
/*                                                                   */
/*  To use this code, compile with no special options (although the  */
/*  TEST option is useful so that the trace back will give           */
/*  additional information - line number information and the type and*/
/*  values of variables will be dumped in a trace back for all       */
/*  files compiled with TEST).                                       */
/*  Prelink (or link) this text deck with your text decks (make sure */
/*  you explicitly link this text deck - avoid using autocall since  */
/*  you might get the C/370 version of malloc/free/realloc).         */
/*                                                                   */
/* INTERNALS:                                                        */
/*                                                                   */
/*  General Algorithm:                                               */
/*                                                                   */
/*  When storage is allocated, extra 'padding' is allocated at the   */
/*  start and end of the actual storage allocated for the user.      */
/*  This padding is then initialized to a special pad value. If the  */
/*  user's code is functioning correctly, the padding should not     */
/*  have been changed when it comes time to free the storage. If the */
/*  free() routine finds that the padding does not have the correct  */
/*  value, the storage about to be freed is dumped and a trace back  */
/*  is issued, and then the storage is dumped, as usual.             */
/*  The padding size and padding byte value can be modified to suit  */
/*  your needs. Update the include file "cbc3gmi1.h" if you want     */
/*  to modify these values.                                          */
/*  Here is a diagram of how storage is allocated (assume that the   */
/*  pad value is xFE, the padding size is 4 bytes and 8 bytes of     */
/*  storage were requested):                                         */
/*                                                                   */
/*  Length of      Padding        Allocated storage          Padding */
/*   storage          |            returned to user             |    */
/*      |             |                     |                   |    */
/* +----+------+ +----+------+ +------------+------------+ +----+----*/
/* |           | |           | |                         | |         */
/*+------------------------------------------------------------------*/
/*| 00 00 00 10 | FE FE FE FE | xx xx xx xx | xx xx xx xx | FE FE FE */
/*+------------------------------------------------------------------*/
/*                                                                   */
/*  (Values above shown in hexadecimal)                              */
/*                                                                   */
/*  This method is fairly effective in tracking down storage         */
/*  allocation problems. Also, code does not have                    */
/*  to be recompiled to use these routines - it just has to be       */
/*  relinked. Note that it is not guaranteed to find all storage     */
/*  allocation errors - if you overwrite the padding with the        */
/*  same value it had before, or you overwrite more storage than     */
/*  you had padding for, you will still have problems.               */
/*                                                                   */
/*  This code uses the LE/370 heap services to allocate, re-allocate */
/*  and free storage. A User Heap is used instead of the library     */
/*  heap so that if the heap gets corrupted, the standard library    */
/*  services that themselves use the heap won't be affected (i.e.    */
/*  if the user heap is damaged, a call to a library function        */
/*  such as printf should still succeed).                            */
/*                                                                   */
/*  Notes of interest:                                               */
/*   - The runtime option STORAGE is very useful for tracking down   */
/*     random pointer problems - it initializes heap and/or stack    */
/*     frame storage to a particular value.                          */
/*   - The runtime option RPTSTG(ON) is useful for improving heap and*/
/*     stack frame allocation - it generates a report indicating how */
/*     stack and heap storage was managed for a given program.       */
/*********************************************************************/
#include "cbc3gmi1.h"
#include <leawi.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <ctest.h>

/*********************************************************************/
/* heapVerbose: external variable that controls whether heap         */
/*              allocation and free messages are displayed.          */
/*********************************************************************/
int heapVerbose=1;

/*********************************************************************/
/* mallocHeapID: static variable that is the Heap ID used for allocat*/
/*               storage via malloc(). On the first call to malloc(),*/
/*               a Heap will be created and this Heap ID will be set.*/
/*               All subsequent calls to malloc will use this Heap ID*/
/*********************************************************************/
static _INT4 mallocHeapID=0;

/*********************************************************************/
/* CHARS_PER_LINE/BYTES_PER_LINE: Used by dump() and DumpLine()      */
/*         to control the width of a storage dump                    */
/*********************************************************************/
#define CHARS_PER_LINE           40
#define BYTES_PER_LINE           16

/*********************************************************************/
/* align: Given a value and the alignment desired (in bits), round   */
/*        the value to the next largest alignment, unless it is      */
/*        already aligned, in which case, just return the value passe*/
/*********************************************************************/
#pragma inline(align)
static int align(int value, int shift) {
  int alignment = (0x1 << shift);

  if (value % alignment) {
    return(((value >> shift) << shift) + alignment);
  }
  else {
    return(value);
  }
}

/*********************************************************************/
/* padding: given a buffer (address and length), return 1 if the     */
/*          entire buffer consists of the pad character specified,   */
/*          otherwise return 0.                                      */
/*********************************************************************/
#pragma inline(padding)
static int padding(const char* buffer, long size, int pad) {
  int i;
  for (i=0;i<size;++i) {
    if (buffer[i] != pad) return(0);
  }
  return(1);
}

/*********************************************************************/
/* CEECmp: Given two feedback codes, return 0 if they have the same  */
/*         message number and facility id, otherwise return 1.       */
/*********************************************************************/
#pragma inline(CEECmp)
static int CEECmp(_FEEDBACK* fc1, _FEEDBACK* fc2) {

  if (fc1->tok_msgno == fc2->tok_msgno &&
      !memcmp(fc1->tok_facid, fc2->tok_facid,
              sizeof(fc1->tok_facid))) {
    return(0);
  }
  else {
    return(1);
  }
}

/*********************************************************************/
/* CEEOk: Given a feedback code, return 1 if it compares the same to */
/*        condition code CEE000.                                     */
/*********************************************************************/
#pragma inline(CEEOk)
static int CEEOk(_FEEDBACK* fc) {
  _FEEDBACK CEE000 = { 0, 0, 0, 0, 0, {0,0,0}, 0 };

  return(CEECmp(fc, &CEE000) == 0);
}

/*********************************************************************/
/* CEEErr: Given a title string and a feedback code, print the       */
/*         title to stderr, then print the message associated        */
/*         with the feedback code. If the feedback code message can't*/
/*         be printed out, print out the message number and severity.*/
/*********************************************************************/
static void CEEErr(const char* title, _FEEDBACK* fc) {
  _FEEDBACK msgFC;
  _INT4 dest = 2;

  fprintf(stderr, "\n%s\n", title);
  CEEMSG(fc, &dest, &msgFC);
  if (!CEEOk(&msgFC)) {
    fprintf(stderr, "Message number:%d with severity %d occurred\n",
            fc->tok_msgno, fc->tok_sev);
  }
}

/*********************************************************************/
/* DumpLine: Dump out a buffer (address and length) to stderr.       */
/*********************************************************************/
static void DumpLine(char* address, int length) {
  int i, c, charCount=0;

  if (length % 4) length += 4;

  fprintf(stderr, "%8.8p: ", address);
  for (i=0; i < length/4; ++i) {
    fprintf(stderr, "%8.8X ", ((int*)address)[i]);
    charCount += 9;
  }
  for (i=charCount; i < CHARS_PER_LINE; ++i) {
    putc(' ', stderr);
  }
  fprintf(stderr, "| ");
  for (i=0; i < length; ++i) {
    c = address[i];
    c = (isprint(c) ? c : '.');
    fprintf(stderr, "%c", c);
  }
  fprintf(stderr, "\n");
}

/*********************************************************************/
/* dump: dump out a buffer (address and length) to stderr by dumping */
/*    it a line at a time (DumpLine), until the buffer is written out*/
/*********************************************************************/
static void dump(void* generalAddress, int length) {
  int curr = 0;
  char* address = (char*) generalAddress;

  while (&address[curr] < &address[length-BYTES_PER_LINE]) {
    DumpLine(&address[curr], BYTES_PER_LINE);
    curr += BYTES_PER_LINE;
  }
  if (curr < length) {
    DumpLine(&address[curr], length-curr);
  }
}

/*********************************************************************/
/* malloc: Create a heap if necessary by calling CEECRHP. This only  */
/*         needs to be done on the first call to malloc(). Verify    */
/*         that the heap creation was ok. If it wasn't, issue an     */
/*         error message and return a NULL pointer.                  */
/*         Write a message to stderr indicating how many bytes       */
/*         are about to be allocated.                                */
/*         Call CEEGTST to allocate the storage requested plus       */
/*         additional padding to be placed at the start and end      */
/*         of the allocated storage. Verify that the storage allocati*/
/*         was successful. If it wasn't, issue an error message and  */
/*         return a NULL pointer.                                    */
/*         Write a message to stderr indicating the address of the   */
/*         allocated storage.                                        */
/*         Initialize the padding to the value of PADDING_BYTE, so th*/
/*         free() will be able to test that the padding was not chang*/
/*         Return the address of the allocated storage (starting afte*/
/*         the padding bytes).                                       */
/*********************************************************************/
void* malloc(long initSize) {
  _FEEDBACK fc;
  _POINTER address=0;
  long totSize;
  long* lenPtr;
  char* msg;
  char* start;
  char* end;

  if (!mallocHeapID) {
    _INT4 heapSize = HEAP_INIT_SIZE;
    _INT4 heapInc  = HEAP_INCR_SIZE;
    _INT4 opts     = HEAP_OPTS;

    CEECRHP(&mallocHeapID, &heapSize, &heapInc, &opts, &fc);
    if (!CEEOk(&fc)) {
      CEEErr("Heap creation failed", &fc);
      return(0);
    }
  }
  if (heapVerbose) {
    fprintf(stderr, "Allocate %d bytes", initSize);
  }
/*********************************************************************/
/* Add the padding size to the total size, then round up to the      */
/* nearest double word                                               */
/*********************************************************************/
  totSize  = initSize + (PADDING_SIZE*2) + sizeof(long);
  totSize  = align(totSize, 3);

  CEEGTST(&mallocHeapID, &totSize, &address, &fc);
  if (!CEEOk(&fc)) {
    msg = "Storage request failed";
    CEEErr(msg, &fc);
    __ctrace(msg);

    return(0);
  }

  lenPtr = (long*) address;
  *lenPtr= initSize;
  start  = ((char*) address) + sizeof(long);
  end    = start + initSize + PADDING_SIZE;

  memset(start, PADDING_BYTE, PADDING_SIZE);
  memset(end,   PADDING_BYTE, PADDING_SIZE);

  if (heapVerbose) {
    fprintf(stderr, " starting at address %p\n", address);
  }

  return(start + PADDING_SIZE);
}

/*********************************************************************/
/* calloc: Call malloc() to allocate the requested amount of storage.*/
/*         If the allocation was successful, initialize the allocated*/
/*         storage to 0.                                             */
/*         Return the address of the allocated storage (or a NULL    */
/*         pointer if malloc returned a NULL pointer).               */
/*********************************************************************/
void* calloc(long initSize) {
  void* ptr;

  ptr = malloc(initSize);
  if (ptr) {
    memset(ptr, 0, initSize);
  }
  return(ptr);
}
/*********************************************************************/
/* realloc: If a NULL pointer is passed, call malloc() directly.     */
/*          Call CEECZST to re-allocate the storage requested plus   */
/*          additional padding to be placed at the start and end     */
/*          of the allocated storage.                                */
/*          Verify that the storage re-allocation was ok. If it      */
/*          wasn't, issue an error message, dump the storage, and    */
/*          return a NULL pointer.                                   */
/*          Write a message to stderr indicating the address of the  */
/*          re-allocated storage.                                    */
/*          Initialize the padding to the value of PADDING_BYTE, so  */
/*          that free() will be able to test that the padding was not*/
/*          changed. Note that the padding at the start of the storag*/
/*          does not need to be allocated, since it was already      */
/*          initialized by an earlier call to malloc().              */
/*          Return the address of the re-allocated storage (starting */
/*          after the padding bytes).                                */
/*********************************************************************/
void* realloc(char* ptr, long initSize) {
  _FEEDBACK fc;
  _POINTER address = (ptr - sizeof(long) - PADDING_SIZE);
  long oldSize;
  long* lenPtr;
  char* start;
  char* end;
  char* msg;
  long newSize = initSize;

  if (ptr == 0) {
    return(malloc(newSize));
  }

  oldSize = *((long*) address);

  if (heapVerbose) {
    fprintf(stderr, "Re-allocate %d bytes from address %p to ",
            newSize, address);
  }

/*********************************************************************/
/* Add the padding size to the total size, then round up to the      */
/* nearest double word                                               */
/*********************************************************************/
  newSize += (PADDING_SIZE*2) + sizeof(long);
  newSize  = align(newSize, 3);
  CEECZST(&address, &newSize, &fc);
  if (!CEEOk(&fc)) {
    msg = "Storage re-allocation failed";

    CEEErr(msg, &fc);
    dump(address, oldSize + (PADDING_SIZE*2) + sizeof(long));
    __ctrace(msg);
    return(0);
  }

  lenPtr = (long*) address;
  *lenPtr= initSize;
  start  = ((char*) address) + sizeof(long);
  end    = start + initSize + PADDING_SIZE;

  memset(end, PADDING_BYTE, PADDING_SIZE);

  if (heapVerbose) {
    fprintf(stderr, "address %p\n", address);
  }

  return(start + PADDING_SIZE);
}
/*********************************************************************/
/* free: Calculate where the start and end of the originally         */
/*       allocated storage was. The start will be different than the */
/*       address passed in because the address passed in points after*/
/*       the padding bytes added by malloc() or realloc().           */
/*       Write a message to stderr indicating what address is about  */
/*       to be freed.                                                */
/*       Verify that the start and end padding bytes have the origina*/
/*       padding value. If they don't, dump out the originally       */
/*       allocated storage and issue a trace.                        */
/*       Free the storage by calling CEEFRST. If the storage free    */
/*       fails, dump out the storage and issue a trace.              */
/*********************************************************************/
void free(char* ptr) {
  _FEEDBACK fc;
  _POINTER address=(void*) (ptr - sizeof(long) - PADDING_SIZE);
  char* start;
  char* end;
  long size;
  long* lenPtr;
  char* msg;

  lenPtr = (long*) address;
  size   = *lenPtr;
  start  = ((char*) address) + sizeof(long);
  end    = start + size + PADDING_SIZE;

  if (heapVerbose) {
    fprintf(stderr, "Free address %p\n", address);
  }
  if (!padding(start, PADDING_SIZE, PADDING_BYTE) ||
      !padding(end, PADDING_SIZE, PADDING_BYTE)) {

    dump(address, size + (PADDING_SIZE*2) + sizeof(long));
    msg = "Padding overwritten";
    __ctrace(msg);
  }
  else {
    CEEFRST(&address, &fc);
    if (!CEEOk(&fc)) {
      msg = "Storage free failed";

      CEEErr(msg, &fc);
      dump(address, size + (PADDING_SIZE*2) + sizeof(long));
      __ctrace(msg);
    }
  }
}
./ ADD NAME=CBC3GMT1 0103-00224-00258-1651-00047-00035-00000-BC0THOR
/*********************************************************************/
/* MTF example 1 (MULTI-TASKING FACILITY)                            */
/* prior to execution, create files a.input, b.input, c.input, and   */
/* d.input that contain some numbers with decimal points separated   */
/* by spaces. There should be the same quantity of numbers in files  */
/* a.input and b.input and also in the c.input and d.input pair. The */
/* output contains the sum of the products of the number pairs from  */
/* each pair of files. for example, if a.input contains 4.5, 3.2,    */
/* 1.5, and 7.4 while file b.input contains 1.1, 1.3, 7.2, and 9.0   */
/* the first line of output will contain the number 86.51 which is   */
/* the sum of (4.5 X 1.1) + (3.2 X 1.3) + (1.5 X 7.2) + (7.4 X 9.0)  */
/* The second line of output shows a similarly derived number from   */
/* the numbers in files c.input and d.input.                         */
/*********************************************************************/

#include <stdio.h>

void fdotprod(char *fn1, char *fn2)
{
    int i, res1;
    double result=0, val1, val2;
    FILE *file1, *file2;

    file1 = fopen(fn1, "r");
    file2 = fopen(fn2, "r");

    while (1)
    {
        res1  = fscanf(file1, "%lf", &val1);
        res1 += fscanf(file2, "%lf", &val2);
        if (res1 != 2)
            break;
        result += val1 * val2;
    }
    if (res1 == 1)
        printf("Error: Files of unequal length\n");
    else
        printf("Result: %lf\n", result);
}

int main(void)
{
    fdotprod("a.input", "b.input");
    fdotprod("c.input", "d.input");

    return(0);
}
./ ADD NAME=CBC3GMT2 0102-00224-00258-1653-00021-00015-00000-BC0THOR
/*********************************************************************/
/* MTF example 2 (MULTI-TASKING FACILITY)                            */
/* part 1 of 2-other file is CBC3GMT3                                */
/* I was unable to get any output from this program, though it       */
/* compiled and executed with no errors.                             */
/* I assume that it somehow accesses the subroutine "fdotprod", which*/
/* is included in CBC3GMT3 (or should).                              */
/*********************************************************************/

#include <mtf.h>

int main(void)
{
    tinit("plmod", 2);
    tsched(MTF_ANY, "fdotprod", "a.input", "b.input");
    tsched(MTF_ANY, "fdotprod", "c.input", "d.input");
    tsyncro(MTF_ALL);
    tterm();

    return(0);
}
./ ADD NAME=CBC3GMT3 0102-00224-00258-1411-00029-00027-00000-BC0THOR
/*********************************************************************/
/* MTF example 2  (multi-tasking facility)                           */
/* Part 2 of 2-other file is cbc3gmt2.                               */
/*********************************************************************/
#include <stdio.h>

void fdotprod(char *fn1, char *fn2)
{
    int i, res1;
    double result=0, val1, val2;
    FILE *file1, *file2;


    file1 = fopen(fn1, "r");
    file2 = fopen(fn2, "r");

    while(1)
    {
        res1  = fscanf(file1, "%lf", &val1);
        res1 += fscanf(file2, "%lf", &val2);
        if (res1 != 2)
            break;
        result += val1 * val2;
    }
    if (res1 == 1)
        printf("Error: Files of unequal length\n");
    else
        printf("Result: %lf\n", result);
}
./ ADD NAME=CBC3GMV1 0102-00224-00277-1655-00086-00070-00000-BC0THOR
/*********************************************************************/
/* This example will display hexadecimal values for the variant      */
/* characters.                                                       */
/* The user must create a file called userid.MYFILE.DAT that contains*/
/* a string of variant characters. These must be the same characters */
/* and in the same order as the names in the char_names table. As    */
/* coded below, that would be backslash, right bracket, left bracket,*/
/* right brace, left brace, circumflex, tilde, exclamation point,    */
/* number sign, and vertical line.                                   */
/*********************************************************************/

#include <stdio.h>
#include <locale.h>
#include <variant.h>
#include <stdlib.h>

void read_user_data(char *, int);

void main() {
  char  *user_char, *compiler_char;

  struct variant *compiler_var_char;
  int num_var_char, index;
  char *code_set;
  char *char_names[]={"backslash",
                      "right bracket",
                      "left bracket",
                      "right brace",
                      "left_brace",
                      "circumflex",
                      "tilde",
                      "exclamation mark",
                      "number sign",
                      "vertical line"};

  num_var_char=sizeof(char_names)/sizeof(char *);
  if ((user_char=(char*)calloc(num_var_char, 1)) == NULL)
  {
    printf("Error: Unable to allocate the storage\n");
    exit(99);
  }

  read_user_data(user_char, num_var_char);
/*********************************************************************/
/* Managed to read the users' characters from the file.              */
/*********************************************************************/

  code_set="default IBM-1047";
  compiler_char="\xe0\xbd\xad\xd0\xc0\x5f\xa1\x5a\x7b\x4f";
/*********************************************************************/
/* Standard compiler code page.                                      */
/*********************************************************************/

  printf("Compiler and library code page is : %s\n\n", code_set);
  printf("                           Variant character values:\n");
  printf(" %16s     expected by compiler    your current\n", "");
  for (index=0; index<num_var_char; index++)
    printf(" %16s  :       %X                      %X\n",
             char_names[index], compiler_char[index], user_char[index¨);
  exit(0);
}

/*********************************************************************/
/* read_user_data() reads a set of variant characters from a file    */
/* provided by the user.                                             */
/*********************************************************************/
void read_user_data(char* char_array, int num_var_char)
{
  FILE  *stream;
  int num;

  if (stream = fopen ("'test.myfile.dat'", "rb"))
    if(!(num = fread(char_array, 1, num_var_char, stream)))
    {
      printf("Error: Unable to read from the file\n");
      exit(99);
    }
    else { ;}
  else
  {
    printf("Error: Unable to open the file\n");
    exit(99);
  }
  fclose(stream);
  return;
}
./ ADD NAME=CBC3GOF1 0101-00224-00259-1046-00022-00020-00000-BC0THOR
/*********************************************************************/
/* This example shows how fopen() may be used with memory files.     */
/*********************************************************************/

#include <stdio.h>
char text[3], *result;
FILE * fp;

int main(void)
   {
   fp = fopen("a.b", "w, type=memory");  /* Opens a memory file */
   fprintf(fp, "%d\n",10);               /* Writes to the file  */
   fclose(fp);                           /* Closes the file     */
   fp = fopen("a.b", "r");               /* Reopens the same    */
                                         /*  file (already      */
                                         /*  a memory file)     */
   if ((result=fgets(text,3,fp)) !=NULL) /* Retrieves results   */
      printf("value retrieved is %s\n",result);
   fclose(fp);                           /* Closes the file     */

   return(0);
   }
./ ADD NAME=CBC3GOP1 0102-00224-00259-1401-00032-00026-00000-BC0THOR
/*********************************************************************/
/* This is used to show optimization with CBC3GOP2.                  */
/* compile errors occur on line 9:                                   */
/*   CBC3277 Syntax error: possible missing ';' or ','?              */
/*   CBC3485 Parameter declaration list is incompatible with declar- */
/*           ator for inline.                                        */
/*********************************************************************/

#include <stdio.h>
inline int which_group (int a) {
   if (a < 0) {
      printf("first group\n");
      return(99);
   }
   else if (a == 0) {
      printf("second group\n");
      return(88);
   }
   else {
      printf("third group\n");
      return(77);
   }
}

int main (void) {

   int j;

   j = which_group (7);

   return(0);
}
./ ADD NAME=CBC3GOP2 0102-00224-00259-1358-00015-00013-00000-BC0THOR
/*********************************************************************/
/* This example demonstrates optimization with CBC3GOP1.             */
/*********************************************************************/

#include <stdio.h>

int main(void) {

   int j;

   printf("third group\n");   /* a lot less code generation */
   j = 77;

   return(0);
}
./ ADD NAME=CBC3GOP3 0101-00224-00259-1404-00020-00018-00000-BC0THOR
/*********************************************************************/
/* This example shows how numeric conversions are done.              */
/*********************************************************************/

int main(void)
{
   int i;
   float array[10];
   float x = 1.0;
   for (i = 0; i < 10; i++)
      {
       array[i] = array[i]*x;  /* No conversions needed */
       x = x + 1.0;
      }

   for (i = 1; i <= 9; i++)
      array[i] = array[i]*i;  /* Multiple conversions needed */

   return(0);
}
./ ADD NAME=CBC3GOS1 0101-00224-00259-1434-00062-00055-00000-BC0THOR
//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,
//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M
//JESOUT OUTPUT GROUPID=HDQTRSF2,DEFAULT=YES,JESDS=ALL,
//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG
//*******************************************************************
//*               BC0THOR.PDS.C(CBC3GOS1)                           *
//*******************************************************************
//********************************************************************/
//* CBC3GOS1 Example                                                 */
//* This example demonstrates GDG I/O                                */
//*                                                                  */
//* Create GDG model MYGDG.MODEL and GDG name MYGDG                  */
//********************************************************************/
//MODEL     EXEC PGM=IDCAMS
//DD1       DD DSN=BC0THOR.MYGDG.MODEL,DISP=(NEW,CATLG),
//             UNIT=SYSDA,SPACE=(TRK,(0)),
//             DCB=(LRECL=80,BLKSIZE=3120,RECFM=FB)
//SYSPRINT  DD SYSOUT=*
//SYSIN     DD *
 DEFINE GDG -
        (NAME(BC0THOR.MYGDG) -
        EMPTY              -
        SCRATCH            -
        LIMIT(255))
/*
//*---------------------------------------------------------------------
//* Create GDG data set MYGDG(+1)
//*---------------------------------------------------------------------
//DATASET   EXEC PGM=IEFBR14
//DD1       DD DSN=BC0THOR.MYGDG(+1),DISP=(NEW,CATLG),
//             SPACE=(CYL,(1,1)),UNIT=SYSDA,
//             DCB=BC0THOR.MYGDG.MODEL
//SYSPRINT  DD SYSOUT=*
//SYSIN     DD DUMMY
//*---------------------------------------------------------------------
//* Compile, link, and run an inlined C program.
//* This program attempts to open the GDG data set MYGDG(+1) but
//* should fail as it is opening the data set with a RECFM that is
//* different from that of the GDG model (F versus FB).
//*---------------------------------------------------------------------
//C        EXEC EDCCLG,
//         CPARM='NOSEQ,NOMARGINS'
//COMPILE.SYSIN DD DATA,DLM='/>'
#include <stdio.h>
#include <errno.h>

int main(void)
{
    FILE *fp;

    fp = fopen("MYGDG(+1)", "a,recfm=F");

    if (fp == NULL)
    {
        printf("Error...Unable to open file\n");
        printf("errno ... %d\n",errno);
        perror("perror ... ");
    }

    printf("Finished\n");
}
/>
./ ADD NAME=CBC3GOS3 0101-00224-00259-1451-00047-00043-00000-BC0THOR
/*********************************************************************/
/* This example demonstrates how updated records are read.           */
/*********************************************************************/

#include <stdio.h>

int main(void)
{
   FILE * fp, * fp2;
   int rc, rc2, rc3, rc4;

   fp = fopen("a.b","w+");

   fprintf(fp,"first record");

   fp2 = fopen("a.b","r");  /* Simultaneous Reader */

/*********************************************************************/
/* Following gets EOF since fp has not completed first line          */
/* of output so nothing will be flushed to file yet.                 */
/*********************************************************************/

   rc = fgetc(fp2);
   printf("return code is %i\n", rc);

   fputc('\n', fp);  /* this will complete first line */
   fflush(fp);       /* ensures data is flushed to file */

   rc2 = fgetc(fp2);  /* this gets 'f' from first record */
   printf("value is now %c\n", rc2);

   rewind(fp);

   fprintf(fp, "some updates\n");

   rc3 = fgetc(fp2);  /* gets 'i' ..doesn't know about update */
   printf("value is now %c\n", rc3);

   fflush(fp);  /* ensure update makes it to file */

   fflush(fp2); /* this updates reader's buffer */

   rc4 = fgetc(fp2);  /* gets 'm', 3rd char of updated record */
   printf("value is now %c\n", rc4);

   return(0);
}
./ ADD NAME=CBC3GRE1 0100-00224-00259-1503-00011-00011-00000-BC0THOR
/* this example demonstrates how to make strings constant */

#pragma strings(readonly)
#include <stdio.h>

int main(void)
{
   printf("hello world\n");

   return(0);
}
./ ADD NAME=CBC3GRE3 0104-00224-00265-1752-00023-00024-00000-BC0THOR
*********************************************************************
* CBC3GRE3 is an assembler subroutine statically called by C program*
* CBC3GRE4. See CBC3GRE4 comments for details.                      *
*                                                                   *
* parameters:  none                                                 *
* return:      none                                                 *
* action:      store contents of register 13 ( callers dynamic      *
*              storage area) in variable DSA which exists in        *
*              the writable static area                             *
*                                                                   *
* Macros:    EDCPRLG, EDCEPIL, EDCDXD, EDCLA in CEE.SCEEMAC         *
*********************************************************************
XOBJHDR  EDCDPLNK            ; generate an XOBJ header
GETDSA   CSECT
GETDSA   AMODE ANY
GETDSA   RMODE ANY
         EDCPRLG             ;  prolog (save registers etc.)
         EDCLA 1,DSA         ;  load register 1 with address of DSA
         ST 13,0(,1)         ;  store contents of reg 13 in DSA
         EDCEPIL             ;  epilog (restore registers etc.)
DSA      EDCDXD 0F           ;  declaration of DSA in writable static
TBLDSA   EDCDXD 20F          ;  definition of TBLDSA in writable static
         END
./ ADD NAME=CBC3GRE4 0103-00224-00265-1800-00047-00037-00000-BC0THOR
/*********************************************************************/
/* This example shows how to reference objects in the writable       */
/* static area, from assembler code.                                 */
/* The assembler program CBC3GRE3 must be assembled and linked prior */
/* to the compile and link for this program so that it can be linked */
/* statically via linkedit autocall from the SYSLIB concatenation.   */
/*********************************************************************/

#include <stdio.h>
#define SZ 20

#ifdef __cplusplus
    extern "OS" {
#endif
void GETDSA(void);               /* assembler routine modifies DSA */
#ifdef __cplusplus
    }
#endif

const int sz = 20;               /* maximum call depth */
extern void * TBLDSA[SZ];         /* defined in assembler program */
void * DSA;                      /* define it here, source name */
                                 /* same as assembler name */

/*********************************************************************/
/* Call yourself deeper and deeper.                                  */
/* Save DSA pointers as you go.                                      */
/*********************************************************************/
void deeper( int i)
{
  if (i >= sz)     /* if deep enough just return */
    return;
  GETDSA();        /* assign value to DSA */
  TBLDSA[i] = DSA;  /* save value in table */
  deeper(i+1);     /* go deeper in call chain */
}

/*********************************************************************/
/* Define the main() function.                                       */
/*********************************************************************/
int main(void) {
  int i;
  deeper(0);
  for(i=0;i<sz; i++)
    printf("depth %3d, DSA was at %p\n", i, TBLDSA[i]);
  return 0;
}
./ ADD NAME=CBC3GTH1 0101-00266-00266-1201-00046-00045-00000-BC0THOR
/* The following example uses thread-specific */
/* data to insure that storage acquired by a specific thread is */
/* freed when the thread ends. */

 #define _OPEN_THREADS
 #include <stdio.h>
 #include <stdlib.h>
 #include <pthread.h>
 pthread_key_t mykey;               /* A place to get the key */
 void mydestruct(void *value);      /* My destructor routine  */
 main()
  {
   char * thddataptr;
  /*  Create a key, getting back the key from pthread_key_create(),
      and associate a function to be executed at thread termination
      for this key
  */

    (void)pthread_key_create(&mykey,&mydestruct);

  /*
    Obtain some storage which this thread will manage (remember,
    the main is also a thread), which we want freed by our
    destructor upon thread termination.  Associate the storage
    pointer with the key using pthread_setspecific.
 */
  thddataptr = (char *) malloc(100);
  (void)pthread_setspecific(mykey,thddataptr);

 /* the body of the function

 /* now, the thread exits, causing the thread termination
    key data destructor to be executed.
 */
   pthread_exit((void *)0);
 }
 /*
    The key data destructor function
*/
 void mydestruct(void * value) {
   /* value is the value in the key/value binding that is unique
      to the thread being terminated.  Thus, in the example,
      it represents the pointer to the storage needing freed.
   */
    free(value);
 }
./ ADD NAME=CBC3GVS1 0101-00264-00265-1356-00037-00035-00000-BC0THOR
/*********************************************************************/
/* This example shows how to access the __amrc->__RBA field.         */
/* It assumes that an ESDS has already been defined, and has been    */
/* assigned the ddname ESDSCLUS.                                     */
/*********************************************************************/

#include <stdio.h>
#include <stdlib.h>

main() {
   FILE *ESDSfile;
   unsigned long myRBA;
   char recbuff[100]="This is record one.";
   int w_retcd;
   int l_retcd;
   int r_retcd;

   printf("calling fopen(\"dd:esdsclus\",\"rb+,type=record\");\n");
   ESDSfile = fopen("dd:esdsclus", "rb+,type=record");
   printf("fopen() returned 0X%.8x\n",ESDSfile);
   if (ESDSfile==NULL) exit;

   w_retcd = fwrite(recbuff, 1, sizeof(recbuff), ESDSfile);
   printf("fwrite() returned %d\n",w_retcd);
   if (w_retcd != sizeof(recbuff)) exit;
   myRBA = __amrc->__RBA;

   l_retcd = flocate(ESDSfile, &myRBA, sizeof(myRBA), __RBA_EQ);
   printf("flocate() returned %d\n",l_retcd);
   if (l_retcd !=0) exit;

   r_retcd = fread(recbuff, 1, sizeof(recbuff), ESDSfile);
   printf("fread() returned %d\n",r_retcd);
   if (l_retcd !=0) exit;

   return(0);
}
./ ADD NAME=CBC3GVS2 0103-00264-00265-1411-00314-00263-00000-BC0THOR
/*********************************************************************/
/* This example demonstrates the use of a KSDS file.                 */
/* Part 1 of 2-other file is CBC3GVS3 (the JCL to execute the sample)*/
/*********************************************************************/

#include <stdio.h>
#include <string.h>

/*********************************************************************/
/* global definitions                                                */
/*********************************************************************/

static void print_amrc(void);
struct data_struct {
              char   emp_number[4];
              char   user_id[8];
              char   name[20];
              char   pers_info[37];
};

#define  REC_SIZE                69
#define  CLUS_KEY_SIZE            4
#define  AIX_UNIQUE_KEY_SIZE      8
#define  AIX_NONUNIQUE_KEY_SIZE  20

static void print_amrc() {
    __amrc_type currErr = *__amrc; /* copy contents of __amrc     */
                                   /* structure so that values    */
                                   /* don't get jumbled by printf */
    printf("R15 value   = %d\n", currErr.__code.__feedback.__rc);
    printf("Reason code = %d\n", currErr.__code.__feedback.__fdbk);
    printf("RBA         = %d\n", currErr.__RBA);
    printf("Last op     = %d\n", currErr.__last_op);
    return;
}
/*********************************************************************/
/* update_emp_rec() function definition.                             */
/*********************************************************************/

int update_emp_rec (struct data_struct *data_ptr,
                    struct data_struct *orig_data_ptr,
                    FILE   *fp)
{
    int          rc;
    char         buffer[REC_SIZE+1];

/*********************************************************************/
/*  Check to see if update will change primary key (emp_number).     */
/*********************************************************************/
    if (memcmp(data_ptr->emp_number,orig_data_ptr->emp_number,4) != 0) {
/*********************************************************************/
/* Check to see if changed primary key exists.                       */
/*********************************************************************/
       rc = flocate(fp,&(data_ptr->emp_number),CLUS_KEY_SIZE,__KEY_EQ);
       if (rc == 0) {
          print_amrc();
          printf("Error: new employee number already exists\n");
          return 10;
       }

       clearerr(fp);

/*********************************************************************/
/* Write out new record.                                             */
/*********************************************************************/
       rc = fwrite(data_ptr,1,REC_SIZE,fp);
       if ((rc == REC_SIZE) || (ferror(fp))) {
          print_amrc();
          printf("Error: write with new employee number failed\n");
          return 20;
       }

/*********************************************************************/
/* Locate to old employee record so it can be deleted.               */
/*********************************************************************/
       rc = flocate(fp,&(orig_data_ptr->emp_number),CLUS_KEY_SIZE,
                    __KEY_EQ);
       if (rc != 0) {
          print_amrc();
          printf("Error: flocate to original employee number failed\n");
          return 30;
       }

       rc = fread(buffer,1,REC_SIZE,fp);
       if (rc != REC_SIZE || ferror(fp)) {
          print_amrc();
          printf("Error: reading old employee record failed\n");
          return 40;
       }

       rc = fdelrec(fp);
       if (rc != 0) {
          print_amrc();
          printf("Error: deleting old employee record failed\n");
          return 50;
       }

   } /* end of checking for change in primary key                */
    else { /* Locate to current employee record                  */
       rc = flocate(fp,&(data_ptr->emp_number),CLUS_KEY_SIZE,__KEY_EQ);
       if (rc == 0) {
/*********************************************************************/
/* Record exists, so update it.                                      */
/*********************************************************************/
          rc = fread(buffer,1,REC_SIZE,fp);
          if (rc != REC_SIZE || ferror(fp)) {
             print_amrc();
             printf("Error: reading old employee record failed\n");
             return 60;
          }

          rc = fupdate(data_ptr,REC_SIZE,fp);
          if (rc == 0) {
             print_amrc();
             printf("Error: updating new employee record failed\n");
             return 70;
          }
       }
       else { /* record doesn't exist so write out new record  */
          clearerr(fp);
          printf("Warning: record previously displayed no longer\n");
          printf("       : exists, new record being created\n");
          rc = fwrite(data_ptr,1,REC_SIZE,fp);
          if (rc != REC_SIZE || ferror(fp)) {
             print_amrc();
             printf("Error: write with new employee number failed\n");
             return 80;
          }
       }
    }
    return 0;
}

/* display_emp_rec() function definition                              */

int display_emp_rec (struct data_struct *data_ptr,
                     struct data_struct *orig_data_ptr,
                     FILE *clus_fp, FILE *aix_unique_fp,
                     FILE *aix_non_unique_fp)
{
    int     rc = 0;
    char    buffer[REC_SIZE+1];

/*********************************************************************/
/* Primary Key Search.                                               */
/*********************************************************************/
    if (memcmp(data_ptr->emp_number, "\0\0\0\0", 4) != 0) {
       rc = flocate(clus_fp,&(data_ptr->emp_number),CLUS_KEY_SIZE,
                    __KEY_EQ);
       if (rc != 0) {
          printf("Error: flocate with primary key failed\n");
          return 10;
       }

/*********************************************************************/
/* Read record for display.                                          */
/*********************************************************************/
       rc = fread(orig_data_ptr,1,REC_SIZE,clus_fp);
       if (rc != REC_SIZE || ferror(clus_fp)) {
          printf("Error: reading employee record failed\n");
          return 15;
       }
    }
/*********************************************************************/
/* Unique Alternate Index Search.                                    */
/*********************************************************************/
    else if (data_ptr->user_id[0] != '\0') {
       rc = flocate(aix_unique_fp,data_ptr->user_id,AIX_UNIQUE_KEY_SIZE,
                   __KEY_EQ);
       if (rc != 0) {
          printf("Error: flocate with user id failed\n");
          return 20;
       }

/*********************************************************************/
/* Read record for display.                                          */
/*********************************************************************/
       rc = fread(orig_data_ptr,1,REC_SIZE,aix_unique_fp);
       if (rc != REC_SIZE || ferror(aix_unique_fp)) {
          printf("Error: reading employee record failed\n");
          return 25;
       }
    }
/*********************************************************************/
/* Non-unique Alternate Index Search.                                */
/*********************************************************************/
    else if (data_ptr->name[0] != '\0') {
       rc = flocate(aix_non_unique_fp,data_ptr->name,
                    AIX_NONUNIQUE_KEY_SIZE,__KEY_GE);
       if (rc != 0) {
          printf("Error: flocate with name failed\n");
          return 30;
       }

/*********************************************************************/
/* Read record for display.                                          */
/*********************************************************************/
       rc = fread(orig_data_ptr,1,REC_SIZE,aix_non_unique_fp);
       if (rc != REC_SIZE || ferror(aix_non_unique_fp)) {
          printf("Error: reading employee record failed\n");
          return 35;
       }
    }
    else {
       printf("Error: invalid search argument; valid search arguments\n"
              "     : are either employee number, user id, or name\n");
       return 40;
    }
/*********************************************************************/
/* Display record data.                                              */
/*********************************************************************/
    printf("Employee Number: %.4s\n", orig_data_ptr->emp_number);
    printf("Employee Userid: %.8s\n", orig_data_ptr->user_id);
    printf("Employee Name:   %.20s\n", orig_data_ptr->name);
    printf("Employee Info:   %.37s\n", orig_data_ptr->pers_info);
    return 0;
}

/*********************************************************************/
/* main() function definition.                                       */
/*********************************************************************/

int main() {
    FILE*               clus_fp;
    FILE*               aix_ufp;
    FILE*               aix_nufp;
    int                 i;
    struct data_struct  buf1, buf2;

    char data[3][REC_SIZE+1] = {
"   1LARRY   LARRY               HI, I'M LARRY,                      ",
"   2DARRYL1 DARRYL              AND THIS IS MY BROTHER DARRYL,      ",
"   3DARRYL2 DARRYL                                                  "
    };

/*********************************************************************/
/* Open file three ways.                                             */
/*********************************************************************/
    clus_fp = fopen("dd:cluster", "rb+,type=record");
    if (clus_fp == NULL) {
       print_amrc();
       printf("Error: fopen(\"dd:cluster\"...) failed\n");
       return 5;
    }
/*********************************************************************/
/* Assume base cluster was loaded with at least one dummy record     */
/* so aix could be defined.                                          */
/*********************************************************************/
    aix_ufp = fopen("dd:aixuniq", "rb,type=record");
    if (aix_ufp == NULL) {
       print_amrc();
       printf("Error: fopen(\"dd:aixuniq\"...) failed\n");
       return 10;
    }
/*********************************************************************/
/* Assume base cluster was loaded with at least one dummy record     */
/* so aix could be defined.                                          */
/*********************************************************************/
    aix_nufp = fopen("dd:aixnuniq", "rb,type=record");
    if (aix_nufp == NULL) {
       print_amrc();
       printf("Error: fopen(\"dd:aixnuniq\"...) failed\n");
       return 15;
    }

/*********************************************************************/
/* Load sample records.                                              */
/*********************************************************************/
    for (i = 0; i < 3; ++i) {
       if (fwrite(data[i],1,REC_SIZE,clus_fp) != REC_SIZE) {
          print_amrc();
          printf("Error: fwrite(data[%d]...) failed\n", i);
          return 66+i;
       }
    }

/*********************************************************************/
/* Display sample record by primary key.                             */
/*********************************************************************/
    memcpy(buf1.emp_number, "   1", 4);
    if (display_emp_rec(&buf1, &buf2, clus_fp, aix_ufp, aix_nufp) != 0)
       return 69;

/*********************************************************************/
/* Display sample record by nonunique aix key.                       */
/*********************************************************************/
    memset(buf1.emp_number, '\0', 4);
    buf1.user_id[0] = '\0';
    memcpy(buf1.name, "DARRYL                    ", 20);
    if (display_emp_rec(&buf1, &buf2, clus_fp, aix_ufp, aix_nufp) != 0)
       return 70;

/*********************************************************************/
/* Display sample record by unique aix key.                          */
/*********************************************************************/
    memcpy(buf1.user_id, "DARRYL2 ", 8);
    if (display_emp_rec(&buf1, &buf2, clus_fp, aix_ufp, aix_nufp) != 0)
       return 71;

/*********************************************************************/
/* Update record just read with new personal info.                   */
/*********************************************************************/
    memcpy(&buf1, &buf2, REC_SIZE);
    memcpy(buf1.pers_info, "AND THIS IS MY OTHER BROTHER DARRYL. ", 37);
    if (update_emp_rec(&buf1, &buf2, clus_fp) != 0) return 72;

/*********************************************************************/
/* Display sample record by unique aix key.                          */
/*********************************************************************/
    if (display_emp_rec(&buf1, &buf2, clus_fp, aix_ufp, aix_nufp) != 0)
       return 73;

    return 0;
}
./ ADD NAME=CBC3GVS3 0100-00277-00277-1419-00023-00023-00000-BC0THOR
1804BC0THOR THORNTON, RICHARD   65 M ISD SYSTEM PROGRAMMER
1937USERQ5  BLAKE, SARA         27 F COM CONSOLE OPERATOR
2179H010736 TOMASINA, ERROL     43 M PRT PRINTER TECHNICIAN
2448T8693   BOBNEY, DALE        60 M ISD ANALYST PROGRAMMER
4779BC0NCAL CALLEY, NANCY       51 F ISD SUPERVISOR
4783CB0GFIN FINNEY, GEORGE      38 M ISD CONTRACTOR
6327B191662 CARROLL, LEWIS      19 M BLD ELECTRICIAN
6328H010399 HOLMES, OLIVER      55 M LEG LAWYER
6329BC0JJON JONES, JOHN P       48 M AUX SHIP CAPTAIN
6330BC1KLAK LAKE, KAREN         39 F HR  HUMAN RESOURCES CLERK
6339T5555   BOHR, NIELS         41 M SCI PHYSICIST
6472USER01  WEST, RONALD        49 M ISD MANAGER, TECHNICAL SERVICES
6478USER03  DEHNE, FERD         44 M ISD SUPERVISOR, TECHNICAL SERV.
7001H013774 HOLDSWORTH, MEREDITH62 F OPS TIVOLI ADMINISTRATOR
7092T4439   RUSSELL, JANIE      29 F OPS TIVOLI INSTALLER
7168USERC4  QUADE, JEFF         37 M ISD SUPERVISOR, TECHNICAL SERV.
8422BC0TWIT WITHEROW, THOMAS    23 M ISD SECURITY TECHNICIAN
8579B010662 TEELE, WAYNE        44 M ISD CONTRACTOR
8644T9364   WATERS, FRANCIS     38 F ISD PROGRAMMER
8739T0249   KLIMECKI, FRANCK    63 M SEC SECURITY GUARD
8956BC0SHAR HARBINGER, STEVEN   56 M SEC ADMINISTRATOR, SECURITY
9099BC0BSIN SINCLAIR, BETSY     39 F FIN FINANCE CLERK
9140BC0DWAT WATLEY, DEAN        44 M ISD FACILITIES LAYOUT TECH.
./ ADD NAME=CBC3GVS4 0101-00265-00265-1619-00115-00107-00000-BC0THOR
/*********************************************************************/
/* This example illustrates the use of an RRDS file.                 */
/*********************************************************************/

#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <env.h>

struct rrds_struct {
   __rrds_key_type   rrds_key;
   char             *rrds_buf;
};

typedef struct rrds_struct RRDS_STRUCT;

main() {

   __amrc_type save_amrc;
FILE              *fileptr;
RRDS_STRUCT        RRDSstruct;
RRDS_STRUCT       *rrds_rec = &RRDSstruct;
char               buffer1[80] =
                      "THIS IS THE FIRST RECORD IN THE FILE.  I"
                      "T WILL BE WRITTEN AT RRN POSITION 2.   ";
char               buffer2[80] =
                      "THIS IS THE SECOND RECORD IN THE FILE. I"
                      "T WILL BE WRITTEN AT RRN POSITION 10.  ";
char               buffer3[80] =
                      "THIS IS THE THIRD RECORD IN THE FILE.  I"
                      "T WILL BE WRITTEN AT RRN POSITION 32.  ";
char               outputbuf[80];
unsigned long      flocate_key = 0;


/*********************************************************************/
/*  Select RRDS record structure 2 by setting __fill to 1            */
/*                                                                   */
/*  1. open an RRDS file record mode  (the cluster must be defined)  */
/*  2. write three records (RRN 2, RRN 10, RRN 32)                   */
/*********************************************************************/
    rrds_rec->rrds_key.__fill = 1;

    fileptr = fopen("DD:RRDSFILE", "wb+,type=record");
    if (fileptr == NULL) {
      save_amrc = *__amrc;  /* need copy of __amrc structure */
      printf("fopen failed errno=%d lastop=%d syscode=%X rc=%d\n",
      errno,
      save_amrc.__last_op,
      save_amrc.__code.__abend.__syscode,
      save_amrc.__code.__abend.__rc);
      perror("fopen");
      exit(99);
    }
    rrds_rec->rrds_key.__recnum = 2;
    rrds_rec->rrds_buf = buffer1;
    fwrite(rrds_rec,1,88, fileptr);

    rrds_rec->rrds_key.__recnum = 10;
    rrds_rec->rrds_buf = buffer2;
    fwrite(rrds_rec,1,88, fileptr);

    rrds_rec->rrds_key.__recnum = 32;
    rrds_rec->rrds_buf = buffer3;
    fwrite(rrds_rec,1,88, fileptr);

/*********************************************************************/
/*  3. set file position to the first record                         */
/*  4. read the first record in the file                             */
/*  5. delete it                                                     */
/*********************************************************************/
    flocate(fileptr, &flocate_key, sizeof(unsigned long), __KEY_FIRST);

    memset(outputbuf,0x00,80);
    rrds_rec->rrds_buf = outputbuf;

    fread(rrds_rec,1, 88, fileptr);
    printf("The first record in the file (this will be deleted):\n");
    printf("RRN %d: %s\n\n",rrds_rec->rrds_key.__recnum,outputbuf);

    fdelrec(fileptr);

/*********************************************************************/
/*  6. locate last record in file and set access direction backwards */
/*  7. read the record                                               */
/*  8. update the record                                             */
/*********************************************************************/
    flocate(fileptr, &flocate_key, sizeof(unsigned long), __KEY_LAST);

    memset(outputbuf,0x00,80);
    rrds_rec->rrds_buf = outputbuf;

    fread(rrds_rec,1, 88, fileptr);
    printf("The last record in the file (this one will be updated):\n");
    printf("RRN %d: %s\n\n",rrds_rec->rrds_key.__recnum,outputbuf);

    memset(outputbuf,0x00,80);
    memcpy(outputbuf,"THIS IS THE UPDATED STRING... ",30);
    fupdate(rrds_rec,88,fileptr);

/*********************************************************************/
/*  9. set _EDC_RRDS_HIDE_KEY environment variable                   */
/* 10. read the next record in sequence (ie. RRN 10) into a          */
/*     + character string                                            */
/*********************************************************************/

    setenv("_EDC_RRDS_HIDE_KEY","Y",1);
    memset(outputbuf,0x00,80);
    fread(outputbuf, 1, 80, fileptr);
    printf("The middle record in the file (read into char string):\n");
    printf("%80s\n\n",outputbuf);

    fclose(fileptr);
}
./ ADD NAME=CBC3GWT1 0102-00269-00269-0951-00029-00025-00000-BC0THOR
*********************************************************************
* Write to operator example. This is an assembler subroutine that   *
* is called by CBC3GWT2, a C program. The C program passes two      *
* parameters, the length, and the text of the message to display.   *
* This program issues the WTO to display the message.               *
*********************************************************************
DYNWTO   CSECT
DYNWTO   AMODE 31
DYNWTO   RMODE ANY
         PRINT GEN
         EDCPRLG                   ALWAYS INCLUDE C PROLOG
         L     6,=A(ACTMSG)        SET SVC35.ACTMSG TO DYN MSG
         LA    7,76                LEN(WTO MESSAGE)-SET MAX 76
         L     5,0(,1)             PARM1 IS
         L     5,0(,5)                 LENGTH OF DYN MESSAGE
         O     5,=X'40000000'      1ST BYTE - PAD CHAR (' ')
         L     4,4(,1)             PARM2 IS DYN MSG ADDR
         MVCL  6,4                 COPY DYNMSG TO SVC35 STRUCT
         CNOP  0,4
         BAL   1,BARNDMSG          BRANCH AROUND SVC35 STRUCT
         DC    AL2(80)             TEXT LENGTH (76+4)
         DC    B'1000000000000000' MCSFLAGS
ACTMSG   DC    CL76' '             ARBITRARY SIZE OF 76
         DC    B'0000000000000000' DESCRIPTOR CODES
         DC    B'0100000000000000' ROUTING CODES
BARNDMSG DS    0H
         SVC   35                  ISSUE SVC 35
         EDCEPIL
         END
./ ADD NAME=CBC3GWT2 0103-00266-00269-0949-00013-00008-00000-BC0THOR
/*********************************************************************/
/* Write to operator example. This C program calls an assembler sub- */
/* routine called DYNWTO, passing it the length and text of a message*/
/* to be displayed. Standard OS linkage conventions are forced by use*/
/* of the #pragma linkage(DYNWTO,OS) directive. Source for the DYNWTO*/
/* program is in CBC3GWT1.                                           */
/*********************************************************************/
 #pragma linkage(DYNWTO,OS)     /* dynwto corrected to DYNWTO */
 void DYNWTO(int, char *);
 main()
 {
  DYNWTO(9,"something");
 }
./ ADD NAME=CBC3RAA  0100-00269-00269-1008-00025-00025-00000-BC0THOR
/*********************************************************************/
/* This example shows how break is used with the switch statement.   */
/* Added night to the enum to provide possibility for testing the    */
/* default for the switch.                                           */
/*********************************************************************/

#include <stdio.h>

enum { morning, afternoon, evening, night} timeofday = night;

int main(void) {

  switch (timeofday) {
    case morning:
      printf("Good Morning\n");
      break;

    case evening:
      printf("Good Evening\n");
      break;

    default:
      printf("Good Day, eh\n");
  }
}
./ ADD NAME=CBC3RAAA 0100-00269-00269-1014-00035-00035-00000-BC0THOR
/*********************************************************************/
/* This is an example of a simple C program. It uses the cos() math  */
/* function and displays the result using printf().                  */
/*********************************************************************/

#include <stdio.h>              /* standard library header that
                                   contains I/O function declarations
                                   such as printf used below          */

#include <math.h>               /* standard library header that
                                   contains math function declarations
                                   such as cos used below             */

#define NUM 46.0                /* Preprocessor directive             */

double x = 45.0;                /* Global variable
                                           definitions                */

double y = NUM;


int main(void)                  /* Function definition
                                   for main function                  */
{
   double z;                    /* Internal variable                  */
   double w;                    /*   definitions                      */

   z = cos(x);                  /* cos is declared in math.h as
                                         double cos(double arg)       */
   w = cos(y);
   printf ("cosine of x is %f\n", z);  /* Print cosine of x           */
   printf ("cosine of y is %f\n", w);  /* Print cosine of y           */

   return(0);
}
./ ADD NAME=CBC3RAAB 0100-00269-00269-1044-00026-00026-00000-BC0THOR
/*********************************************************************/
/* This sample program calls another C program, which is the function*/
/* max(). The source code for max() is in CBC3RMAX.                  */
/*********************************************************************/
#include <stdio.h>

#define ONE     1
#define TWO     2
#define THREE   3
extern int max(int, int);           /* Function declaration */

int main(int argc, char * argv[])  /* Function definition */
{
   int u, w, x, y, z;

   u = 5;
   z = 2;
   w = max(u,ONE);
   x = max(w,TWO);
   y = max(x,THREE);
   z = max(y,z);

   printf("w is %d, x is %d, y is %d, z is %d",w,x,y,z);

   return(0);
}
./ ADD NAME=CBC3RAAD 0100-00269-00269-1134-00025-00025-00000-BC0THOR
/*********************************************************************/
/* This example shows how character constants are used */
/*********************************************************************/

#include <stdio.h>
#include <stdlib.h>

char ch1 = 'd';
char ch2 = 'abcd';
char ch3 = '\204';
char ch4 = '\x84';
wchar_t wch1 = L'd';
wchar_t wch2 = L'abcd';
wchar_t wch3 = L'\204';
wchar_t wch4 = L'\x84';

int main(void)
  {
  printf("ch1  = %c, ch2  = %c\n", ch1, ch2);
  printf("ch3  = %c, ch4  = %c\n", ch3, ch4);
  printf("wch1 = %lc, wch2 = %lc\n", wch1, wch2);
  printf("wch3 = %lc, wch4 = %lc\n", wch3, wch4);

  return(0);
  }
./ ADD NAME=CBC3RAAE 0100-00269-00269-1147-00020-00020-00000-BC0THOR
/*********************************************************************/
/* This example shows how string literals are used with the string   */
/* functions strcpy() and strcat().                                  */
/*********************************************************************/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char ch1[20];
char ch2[20] = "Example!!";

int main(void)
  {
  strcpy(ch1, "My ");
  strcat(ch1, ch2);
  printf("ch1 = %s\n", ch1);

  return(0);
  }
./ ADD NAME=CBC3RAAF 0100-00269-00269-1206-00027-00027-00000-BC0THOR
/*********************************************************************/
/* This example illustrates the use of auto variables.               */
/*********************************************************************/

    #include <stdio.h>

    int main(void)
    {
       void call_func(int passed_var);
       auto int auto_var = 1; /* first definition of auto_var  */

       {
          int auto_var = 2;   /* second definition of auto_var */
          printf("inner auto_var = %d\n", auto_var);
       }
       call_func(auto_var);
       printf("outer auto_var = %d\n", auto_var);

       return(0);
    }

    void call_func(int passed_var)
    {
       printf("passed_var = %d\n", passed_var);
       passed_var = 3;
       printf("passed_var = %d\n", passed_var);
    }
./ ADD NAME=CBC3RAAG 0101-00269-00269-1215-00037-00034-00000-BC0THOR
/*********************************************************************/
/* This example passes an array name to a function. letters are read */
/* from the default input file and are placed into an array that is  */
/* passed to included function sort(), which sorts the letters in    */
/* ascending order. on return, the sorted array is printed.          */
/*********************************************************************/

#include <stdio.h>
#include <string.h>

int main(void)
{
   void sort(char *array, int n);
   char string[75];
   int length;
   printf("Enter letters:\n");
   scanf("%74s", string);
   length = strlen(string);
   sort(string,length);
   printf("The sorted string is: %s\n", string);

   return(0);
}
void sort(char *array, int n)
{
   int gap, i, j, temp;

   for (gap = n / 2; gap > 0; gap /= 2)
      for (i = gap; i < n; i++)
         for (j = i - gap; j >= 0 &&array[j] > array[j + gap];
            j -= gap)
         {
            temp = array[j];
            array[j] = array[j + gap];
            array[j + gap] = temp;
         }
}
./ ADD NAME=CBC3RAAI 0100-00269-00269-1222-00037-00037-00000-BC0THOR
/*********************************************************************/
/* This example shows how extern variables are used by two functions */
/*********************************************************************/

#include <stdio.h>
#include <string.h>

char string[75];
int length;

int main(void)
{
   void sort(void);

   printf("Enter letters:\n");
   scanf("%s", string);
   length = strlen(string);
   sort();
   printf("The sorted string is: %s\n", string);

   return(0);
}
void sort(void)
{
   int gap, i, j, temp;

   for (gap = length / 2; gap > 0; gap /= 2)
      for (i = gap; i < length; i++)
         for (j = i - gap;
              j >= 0 && string[j] > string[j + gap];
              j -= gap)
         {
            temp = string[j];
            string[j] = string[j + gap];
            string[j + gap] = temp;
         }
}
./ ADD NAME=CBC3RAAK 0100-00269-00269-1236-00023-00023-00000-BC0THOR
/*********************************************************************/
/* This program illustrates the use of block scope static variables. */
/*********************************************************************/

#include <stdio.h>

int main(void)
{
   void test(void);
   int counter;
   for (counter = 1; counter <= 4; ++counter)
      test();

   return(0);
}
void test(void)
{
   static int stat_var = 0;
   auto int auto_var = 0;
   stat_var++;
   auto_var++;
   printf("stat_var = %d auto_var = %d\n", stat_var, auto_var);
}
./ ADD NAME=CBC3RAAM 0100-00269-00269-1243-00027-00027-00000-BC0THOR
/*********************************************************************/
/* This example uses the void data type.                             */
/*********************************************************************/

    #include <stdio.h>
    /* declaration of function find_max */
    extern void find_max(int x[ ], int j);

    int main(void)
    {
       static int numbers[ ] = { 99, 54, -102, 89 };

       find_max(numbers, (sizeof(numbers) / sizeof(numbers[0])));

       return(0);
    }
    void find_max(int x[ ], int j)
    { /* begin definition of function find_max */
       int i, temp = x[0];

       for (i = 1; i < j; i++)
       {
           if (x[i] > temp)
              temp = x[i];
       }
       printf("max number = %d\n", temp);
    } /* end definition of function find_max  */
./ ADD NAME=CBC3RAAN 0101-00269-00269-1301-00055-00054-00000-BC0THOR
/*********************************************************************/
/* This example demonstrates the use of enum. a prototype was added  */
/* for the french() function, and the old-style function header for  */
/* french() was updated to modern syntax.                            */
/* User enters a number indicating day of week as 1-7.               */
/*********************************************************************/

#include <stdio.h>

enum days {
            Monday=1, Tuesday, Wednesday,
            Thursday, Friday, Saturday, Sunday
          } weekday;

void french(enum days);

int main(void)
{
   int num;

   printf("Enter an integer for the day of the week.  "
          "Mon=1,...,Sun=7\n");
   scanf("%d", &num);
   weekday=num;
   french(weekday);
   return(0);
}
void french(enum days weekday)  {
   switch (weekday)
   {
      case Monday:
         printf("Le jour de la semaine est lundi.\n");
         break;
      case Tuesday:
         printf("Le jour de la semaine est mardi.\n");
         break;
      case Wednesday:
         printf("Le jour de la semaine est mercredi.\n");
         break;
      case Thursday:
         printf("Le jour de la semaine est jeudi.\n");
         break;
      case Friday:
         printf("Le jour de la semaine est vendredi.\n");
         break;
      case Saturday:
         printf("Le jour de la semaine est samedi.\n");
         break;
      case Sunday:
         printf("Le jour de la semaine est dimanche.\n");
         break;
      default:
         printf("C'est le mauvais jour.\n");
   }
}
./ ADD NAME=CBC3RAAO 0100-00269-00269-1321-00030-00030-00000-BC0THOR
/*********************************************************************/
/* This example uses a one-dimensional array.                        */
/*********************************************************************/

#include <stdio.h>
#define  ARR_SIZE  5

int main(void)
{
  static float const prices[ARR_SIZE] = { 1.41, 1.50, 3.75,
     5.00, .86 };
  auto float total;
  int i;

  for (i = 0; i < ARR_SIZE; i++)
  {
    printf("price = $%.2f\n", prices[i]);
  }

  printf("\n");

  for (i = 0; i < ARR_SIZE; i++)
  {
    total = prices[i] * 1.05;

    printf("total = $%.2f\n", total);
  }

  return(0);
}
./ ADD NAME=CBC3RAAP 0100-00269-00269-1326-00027-00027-00000-BC0THOR
/*********************************************************************/
/* This example uses a multi-dimensional array.                      */
/*********************************************************************/

#include <stdio.h>
#define  NUM_ROW     3
#define  NUM_COLUMN  5

int main(void)
{
  static int salary_tbl[NUM_ROW][NUM_COLUMN] =
  {
    {  500,  550,  600,  650,  700   },
    {  600,  670,  740,  810,  880   },
    {  740,  840,  940, 1040, 1140   }
  };
  int grade , step;

  for (grade = 0; grade < NUM_ROW; ++grade)
   for (step = 0; step < NUM_COLUMN; ++step)
   {
     printf("salary_tbl[%d] [%d] = %d\n", grade,
        step, salary_tbl[grade][step]);
   }

   return(0);
}
./ ADD NAME=CBC3RAAQ 0100-00269-00269-1332-00042-00042-00000-BC0THOR
/*********************************************************************/
/* This program searches for the first occurrence of a specified     */
/* character string in an array of character strings.                */
/*********************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#define  SIZE  20

int main(void)
{
   static char *names[] = { "Jim", "Amy", "Mark", "Sue", NULL };
   char * find_name(char **, char *);
   char new_name[SIZE], *name_pointer;

   printf("Enter name to be searched.\n");
   scanf("%s", new_name);
   name_pointer = find_name(names, new_name);
   printf("name %s%sfound\n", new_name,
          (name_pointer == NULL) ? " not " : " ");
   exit(EXIT_FAILURE);
} /* End of main */

/*******************************************************************/
/* Function find_name-this function searches an array of           */
/* names to see if a given name already exists in the array,       */
/* returns a pointer to the name or NULL if the name is not found. */
/*                                                                 */
/* char **arry is a pointer to arrays of pointers (existing names) */
/* char *strng is a pointer to character array entered (new name)  */
/*******************************************************************/

char * find_name(char **arry, char *strng)
{
   for (; *arry != NULL; arry++)         /* for each name          */
   {
      if (strcmp(*arry, strng) == 0)     /* if strings match       */
         return(*arry);                  /* found it!              */
   }
   return(*arry);                        /* return the pointer     */
} /* End of find_name */
./ ADD NAME=CBC3RAAR 0101-00269-00269-1350-00020-00022-00000-BC0THOR
/*********************************************************************/
/* This example uses an abstract data type.                          */
/* part 1 of 2-other file is CBC3RAR1, a header file.                */
/*********************************************************************/

#include "cbc3rar1.h"

int main()
{
  int ctl1, ctl2;
  ControlBlock* ctl;

  ctl = GetControlBlock();     /* allocate and return a control block */

  ctl1 = UpdateControlBlock(ctl,27);/*update the control block with 27*/

  ctl2 = UseControlBlock(ctl);       /* use the updated control block */

  return(0);
}
./ ADD NAME=CBC3RAAS 0100-00269-00269-1357-00034-00034-00000-BC0THOR
/*********************************************************************/
/* This program illustrates linked lists.                            */
/*********************************************************************/

#include <stdio.h>

struct record {
                int number;
                struct record *next_num;
              };

int main(void)
{
   struct  record name1, name2, name3;
   struct  record *recd_pointer = &name1;
   int sum = 0;

   name1.number = 144;
   name2.number = 203;
   name3.number = 488;

   name1.next_num = &name2;
   name2.next_num = &name3;
   name3.next_num = NULL;

   while (recd_pointer != NULL)
   {
      sum += recd_pointer->number;
      recd_pointer = recd_pointer->next_num;
   }
   printf("Sum = %d\n", sum);

   return(0);
}
./ ADD NAME=CBC3RAAT 0100-00270-00270-1527-00034-00034-00000-BC0THOR
/*********************************************************************/
/* This example uses an array of pointers to functions.              */
/*********************************************************************/

#include <stdio.h>
int func1(void);
void func2(double a);

int main(void)
{
   double num;
   int retnum;
   void (*ary[2]) ();
   ary[0] = ((void(*)())func1);
   ary[1] = ((void(*)())func2);

   retnum=((int (*)())ary[0])();      /*  calls func1  */
   printf("number returned = %i\n", retnum);
   ((void (*)(double))ary[1])(num);   /*  calls func2  */

   return(0);
}

int func1(void)
{
int number=3;
return number;
}

void func2(double a)
{
a=333.3333;
printf("result of func2 = %f\n", a);
}
./ ADD NAME=CBC3RAAU 0100-00270-00270-1629-00031-00031-00000-BC0THOR
/*********************************************************************/
/* This example uses a prototype function declarator.                */
/*********************************************************************/

#include <stdio.h>

void sort(int table[], int length);   /* sort function protoype */

int main(void)
{
  int table[]={1,5,8,4};
  int length=4;
  printf("length is %d\n",length);
  sort(table,length);
}
/*********************************************************************/
/* This is the sort function definition                              */
/*********************************************************************/
void sort(int table[], int length)
{
  int i, j, temp;

  for (i = 0; i < length -1; i++)
    for (j = i + 1; j < length; j++)
      if (table[i] > table[j])
      {
        temp = table[i];
        table[i] = table[j];
        table[j] = temp;
      }
}
./ ADD NAME=CBC3RAAV 0100-00270-00270-1634-00023-00023-00000-BC0THOR
/*********************************************************************/
/* This example shows how a function is declared and defined.        */
/*********************************************************************/

#include <stdio.h>
double absolute(double);

int main(void)
{
   double f = -3.0;

   printf("absolute number = %f\n", absolute(f));

   return(0);
}

double absolute(double number)
{
   if (number < 0.0)
      number = -number;

   return (number);
}
./ ADD NAME=CBC3RAAX 0100-00271-00271-0832-00023-00023-00000-BC0THOR
/*********************************************************************/
/* This example shows how a parameter is passed to a function.       */
/*********************************************************************/

#include <stdio.h>
void increment(int);

int main(void)
{
  int count = 5;

  /* value of count is passed to the function */
  increment(count);
  printf("count = %d\n", count);

  return(0);
}

void increment(int x)
{
  ++x;
  printf("x = %d\n", x);
}
./ ADD NAME=CBC3RAAY 0100-00271-00271-0837-00026-00026-00000-BC0THOR
/*********************************************************************/
/* This example shows how an address is passed to a function.        */
/*********************************************************************/

#include <stdio.h>

int main(void)
{
  void increment(int *x);
  int count = 5;

  /* address of count is passed to the function */
  increment(&count);
  printf("count = %d\n", count);

  return(0);
}
/*********************************************************************/
/* This is the increment() function.                                 */
/*********************************************************************/

void increment(int *x)
{
  ++*x;
  printf("*x = %d\n", *x);
}
./ ADD NAME=CBC3RAAZ 0100-00271-00271-0842-00026-00026-00000-BC0THOR
/*********************************************************************/
/* This example shows how loss of precision occurs during type       */
/* conversion.                                                       */
/*********************************************************************/

#include <stdio.h>

int main(void)
{

  int i;
  float f;
  double d;
  long double ld;

  i = 1234567890;
  f = i;
  d = i;
  ld = i;
  printf("i  = %d\n", i);
  printf("f  = %20.10Lf\n", f);
  printf("d  = %20.10Lf\n", d);
  printf("ld = %20.10Lf\n", ld);

  return(0);
}
./ ADD NAME=CBC3RAA1 0100-00271-00271-0850-00021-00021-00000-BC0THOR
/*********************************************************************/
/* This example shows how the values of data objects change in       */
/* nested blocks.                                                    */
/*********************************************************************/

    #include <stdio.h>

    int main(void)
    {
       int x = 1;                     /* Initialize x to 1  */
       int y = 3;

       if (y > 0)
       {
          int x = 2;                  /* Initialize x to 2  */
          printf("second x = %4d\n", x);
       }
       printf("first  x = %4d\n", x);

       return(0);
    }
./ ADD NAME=CBC3RAA2 0100-00271-00271-0855-00028-00028-00000-BC0THOR
/*********************************************************************/
/* This program counts the characters in the strings that are        */
/* part of an array of pointers to characters.                       */
/* The count stops when one of the digits 0 through 9 is             */
/* encountered and resumes at the beginning of the next string.      */
/*********************************************************************/

#include <stdio.h>
#define  SIZE  3

int main(void)
{
   static char *strings[SIZE] = { "ab", "c5d", "e5" };
   int i;
   int letter_count = 0;
   char *pointer;

   for (i = 0; i < SIZE; i++)        /* for each string    */
      for (pointer = strings[i]; *pointer != '\0'; ++pointer)
      {
         if (*pointer >= '0' && *pointer <= '9')
            break;
         letter_count++;
      }
   printf("letter count = %d\n", letter_count);

   return(0);
}
./ ADD NAME=CBC3RAA3 0100-00271-00271-0859-00022-00022-00000-BC0THOR
/*********************************************************************/
/* This example shows how the continue statement can be used.        */
/*********************************************************************/

#include <stdio.h>
#define  SIZE  5

int main(void)
{
   int i;
   static float rates[SIZE] = { 1.45, 0.05, 1.88, 2.00, 0.75 };

   printf("Rates over 1.00\n");
   for (i = 0; i < SIZE; i++)
   {
      if (rates[i] <= 1.00)  /*  skip rates <= 1.00  */
         continue;
      printf("rate = %.2f\n", rates[i]);
   }

   return(0);
}
./ ADD NAME=CBC3RAA4 0100-00271-00271-0916-00027-00027-00000-BC0THOR
/*********************************************************************/
/* This program counts the characters in strings that are part of an */
/* array of pointers to characters. The count excludes the digits    */
/* 0 through 9.                                                      */
/*********************************************************************/

#include <stdio.h>
#define  SIZE  3

int main(void)
{
   static char *strings[SIZE] = { "ab", "c5d", "e5" };
   int i;
   int letter_count = 0;
   char *pointer;
   for (i = 0; i < SIZE; i++)            /* for each string         */
                                         /* for each character      */
      for (pointer = strings[i]; *pointer != '\0'; ++pointer)
      {                                  /* if a number             */
         if (*pointer >= '0' && *pointer <= '9')
            continue;
         letter_count++;
      }
   printf("letter count = %d\n", letter_count);

   return(0);
}
./ ADD NAME=CBC3RAA5 0100-00271-00271-0922-00018-00018-00000-BC0THOR
/*********************************************************************/
/* This example illustrates the do statement.                        */
/*********************************************************************/

#include <stdio.h>

int main (void)
{
   int reply1;

   do
   {
      printf("Enter a 1\n");
      scanf("%d", &reply1);
   } while (reply1 != 1);

   return(0);
}
./ ADD NAME=CBC3RAA6 0100-00271-00271-0928-00028-00028-00000-BC0THOR
/*********************************************************************/
/* This example shows how a goto statement may be used.              */
/*********************************************************************/

#include <stdio.h>
void display(int matrix[3][3]);

int main(void)
{
   int matrix[3][3]={1,2,3,4,5,2,8,9,10};
   display(matrix);
   return(0);
}

void display(int matrix[3][3])
{
   int i, j;

   for (i = 0; i < 3; i++)
      for (j = 0; j < 3; j++)
      {
         if ( (matrix[i][j] < 1) || (matrix[i][j] > 6) )
            goto out_of_bounds;
         printf("matrix[%d][%d] = %d\n", i, j, matrix[i][j]);
      }
   return;
   out_of_bounds: printf("number must be 1 through 6\n");
}
./ ADD NAME=CBC3RAA7 0100-00271-00271-0931-00021-00021-00000-BC0THOR
/*********************************************************************/
/* This example shows how the while statement may be used.           */
/*********************************************************************/

#define MAX_INDEX  (sizeof(item) / sizeof(item[0]))
#include <stdio.h>

int main(void)
{
   static int item[ ] = { 12, 55, 62, 85, 102 };
   int index = 0;

   while (index < MAX_INDEX)
   {
      item[index] *= 3;
      printf("item[%d] = %d\n", index, item[index]);
      ++index;
   }

   return(0);
}
./ ADD NAME=CBC3RAA8 0100-00271-00271-0934-00020-00020-00000-BC0THOR
/*********************************************************************/
/* This example illustrates the use of a macro.                      */
/*********************************************************************/

#include <stdio.h>

#define SQR(s)  ((s) * (s))
#define PRNT(a,b) \
{ printf("value 1 = %d\n", a); \
  printf("value 2 = %d\n", b) ; }

int main(void)
{
  int x = 2;
  int y = 3;

  PRNT(SQR(x),y);

  return(0);
}
./ ADD NAME=CBC3RAA9 0100-00271-00271-0936-00017-00017-00000-BC0THOR
/*********************************************************************/
/* This example is equivalent to CBC3RAA8.                           */
/*********************************************************************/

#include <stdio.h>

int main(void)
{
  int x = 2;
  int y = 3;
  {
     printf("value 1 = %d\n", ( (x) * (x) ) );
     printf("value 2 = %d\n", y);
  }

  return(0);
}
./ ADD NAME=CBC3RABA 0100-00271-00271-0941-00015-00015-00000-BC0THOR
/*********************************************************************/
/* This example shows how predefined macros are used.                */
/* part 1 of 2-other file is CBC3RAB1.H                              */
/*********************************************************************/

#include <stdio.h>
#include "cbc3rab1.h"

int main(void)
{
   printf("At line %d of file %s\n", __LINE__, __FILE__);
   testsub();      /* Call to function defined in cbc3rab1.h */

   return(0);
}
./ ADD NAME=CBC3RABB 0100-00271-00271-0945-00021-00021-00000-BC0THOR
/*********************************************************************/
/* This example shows how predefined macros are used.                */
/*********************************************************************/

#pragma langlvl(ANSI)
#include <stdio.h>

#ifdef __STDC__
   #define CONFORM    "conforms"
#else
   #define CONFORM    "does not conform"
#endif

int main(void)
{
  printf("Line %d of file %s has been executed\n", __LINE__,__FILE__);
  printf("This file was compiled at %s on %s\n", __TIME__,__DATE__);
  printf("This program %s to ANSI standards\n", CONFORM);

  return(0);
}
./ ADD NAME=CBC3RABC 0100-00271-00271-0949-00021-00021-00000-BC0THOR
/*********************************************************************/
/* This example uses conditional compilation directives.             */
/*********************************************************************/

int main(void)
{
   static int array[ ] = { 1, 2, 3, 4, 5 };
   int i;

   for (i = 0; i <= 4; i++)
   {
      array[i] *= 2;

      #if TEST >= 1
         printf("i = %d\n", i);
         printf("array[i]  = %d\n", array[i]);
      #endif
   }

   return(0);
}
./ ADD NAME=CBC3RABD 0100-00271-00271-1018-00025-00025-00000-BC0THOR
/*********************************************************************/
/* This example shows how #line is used.                             */
/*********************************************************************/

#include <stdio.h>
#define LINE200 200

int main(void)
{
   func_1();
   func_2();
   return(0);
}

#line 100
func_1()
{
   printf("Func_1 - the current line number is %d\n",__LINE__);
}

#line LINE200
func_2()
{
   printf("Func_2 - the current line number is %d\n",__LINE__);
}
./ ADD NAME=CBC3RABE 0100-00271-00271-1024-00061-00061-00000-BC0THOR
/*********************************************************************/
/* This example shows how #pragma inline may be used.                */
/*********************************************************************/
#pragma csect(code,"MYCFILE")
#pragma csect(static,"MYSFILE")
#pragma options(INLINE)
#include <stdio.h>
#include <stdlib.h>
static int (writerecord) (int, char *);
#pragma inline (writerecord)
int main()
{
   int chardigit;
   int digit;
   printf("Enter a digit\n");
   chardigit = getchar();
   digit = chardigit - '0';
   if (digit < 0 || digit > 9)
     {
      printf("invalid digit\n");
      exit(99);
     }
   switch(digit)
     {
      case 0:
         writerecord(0, "entered 0");
         break;
      case 1:
         writerecord(1, "entered 1");
         break;
      default:
         writerecord(9, "entered other");
     }
}
static int writerecord (int digit, char *phrase)
{
   switch (digit)
     {
      case 0:
         printf("writerecord 0: ");
         printf("%s\n", phrase);
         break;
      case 1:
         printf("writerecord 1: ");
         printf("%s\n", phrase);
         break;
      case 2:
         printf("writerecord 2: ");
         printf("%s\n", phrase);
         break;
      case 3:
         printf("writerecord 3: ");
         printf("%s\n", phrase);
         break;
      default:
         printf("writerecord X: ");
         printf("%s\n", phrase);
      }

    return 0;
}
./ ADD NAME=CBC3RABF 0100-00271-00271-1032-00031-00031-00000-BC0THOR
/*********************************************************************/
/* This example illustrates blocks, nesting, and scope.              */
/*********************************************************************/

 #include <stdio.h>
 int i = 1;                         /* i defined at file scope */

 int main(int argc, char * argv[])
 {

    printf("%d\n", i);                     /* Prints 1 */

    {
       int i = 2, j = 3;            /* i and j defined at
                                       block scope */
       printf("%d\n%d\n", i, j);                  /* Prints 2, 3 */

       {
          int i = 0;                /* i is redefined in a nested block     */
                                    /* previous definitions of i are hidden */
          printf("%d\n%d\n", i, j); /* Prints 0, 3 */
       }

       printf("%d\n", i);                  /* Prints 2 */

    }

    printf("%d\n", i);                     /* Prints 1 */

    return(0);
 }
./ ADD NAME=CBC3RABG 0100-00271-00271-1038-00030-00030-00000-BC0THOR
/*********************************************************************/
/* This example prints out ctest characters.                         */
/*********************************************************************/

#include <stdio.h>
#include <ctype.h>

int main(void)
{
   int ch;

   for (ch = 0; ch <= 0xff; ch++)
      {
      printf("%#04X ", ch);
      printf("%3s ", isalnum(ch)  ? "AN" : " ");
      printf("%2s ", isalpha(ch)  ? "A"  : " ");
      printf("%2s",  iscntrl(ch)  ? "C"  : " ");
      printf("%2s",  isdigit(ch)  ? "D"  : " ");
      printf("%2s",  isgraph(ch)  ? "G"  : " ");
      printf("%2s",  islower(ch)  ? "L"  : " ");
      printf("%c",  isprint(ch)  ? ch   : ' ');
      printf("%3s",  ispunct(ch)  ? "PU" : " ");
      printf("%2s",  isspace(ch)  ? "S"  : " ");
      printf("%3s",  isprint(ch)  ? "PR" : " ");
      printf("%2s",  isupper(ch)  ? "U"  : " ");
      printf("%2s",  isxdigit(ch) ? "X"  : " ");

      putchar('\n');
      }
}
./ ADD NAME=CBC3RABI 0100-00271-00271-1039-00049-00049-00000-BC0THOR
/*********************************************************************/
/* This example shows how the switch statement may be used.          */
/*********************************************************************/

#include <stdio.h>

int main(void)
{
  int month;

  /* Read in a month value */
  printf("Enter month: ");
  scanf("%d", &month);

  /* Tell what season it falls into */
  switch (month)
  {
     case 12:
     case 1:
     case 2:
        printf("month %d is a winter month\n", month);
        break;

     case 3:
     case 4:
     case 5:
        printf("month %d is a spring month\n", month);
        break;

     case 6:
     case 7:
     case 8:
        printf("month %d is a summer month\n", month);
        break;

     case 9:
     case 10:
     case 11:
        printf("month %d is a fall month\n", month);
        break;

     case 66:
     case 99:
     default:
        printf("month %d is not a valid month\n", month);
  }

  return(0);
}
./ ADD NAME=CBC3RABQ 0100-00271-00271-1047-00041-00041-00000-BC0THOR
/*********************************************************************/
/* This program searches for the first occurrence of a specified     */
/* character string in an array of character strings.                */
/*********************************************************************/

#include <stdio.h>

#include <stdlib.h>

#define  SIZE  20

int main(void)
{
   static char *names[] = { "Jim", "Amy", "Mark", "Sue", NULL };
   char * find_name(char **, char *);
   char new_name[SIZE], *name_pointer;

   printf("Enter name to be searched.\n");
   scanf("%s", new_name);
   name_pointer = find_name(names, new_name);
   printf("name %s%sfound\n", new_name,
          (name_pointer == NULL) ? " not " : " ");
   exit(EXIT_FAILURE);
} /* End of main */

/* function find_name-this function searches an array of           */
/* names to see if a given name already exists in the array,       */
/* returns a pointer to the name or NULL if the name is not found  */

/* char **arry is a pointer to arrays of pointers (existing names) */
/* char *strng is a pointer to character array entered (new name)  */

char * find_name(char **arry, char *strng)
{
   for (; *arry != NULL; arry++)         /* for each name          */
   {
      if (strcmp(*arry, strng) == 0)     /* if strings match       */
         return(*arry);                  /* found it!              */
   }
   return(*arry);                        /* return the pointer     */
} /* End of find_name */
./ ADD NAME=CBC3RAB1 0100-00271-00271-1053-00012-00012-00000-BC0THOR
/*********************************************************************/
/* This example shows how predefined macros are used.                */
/* part 2 of 2-other file is CBC3RABA                                */
/*********************************************************************/

#include <stdio.h>

testsub()
{
   printf("At line %d of file %s\n", __LINE__, __FILE__);
   return;
}
./ ADD NAME=CBC3RAH1 0100-00271-00271-1104-00020-00020-00000-BC0THOR
/*********************************************************************/
/* This example shows the linkage of extern objects/functions.       */
/* part 1 of 3-other files are CBC3RAH2, CBC3RAH3.                   */
/* In this file, the program receives the price of an item,          */
/* adds the tax, and prints the total cost of the item.              */
/*********************************************************************/

     #include <stdio.h>

     int main(void)
     {        /* begin main */
        void tally(void);   /* declaration of function tally */
        extern float total; /* first declaration of total    */

        printf("Enter the purchase amount: \n");
        tally();
        printf("\nWith tax, the total is:  %.2f\n", total);

        return(0);
     }        /* end main */
./ ADD NAME=CBC3RAH2 0100-00271-00271-1107-00017-00017-00000-BC0THOR
/*********************************************************************/
/* This file defines the function tally.                             */
/* Part 2 of 3-other files are CBC3RAH1, CBC3RAH3.                   */
/*********************************************************************/

     #include <stdio.h>
     #define tax_rate 0.05

     void tally(void)
     {   /* begin tally */
        float tax;
        extern float total; /* second declaration of total       */

        scanf("%f", &total);
        tax = tax_rate * total;
        total += tax;
     }   /* end tally */
./ ADD NAME=CBC3RAH3 0100-00271-00271-1109-00006-00006-00000-BC0THOR
/*********************************************************************/
/* part 3 of 3-other files are CBC3RAH1, CBC3RAH2.                   */
/*********************************************************************/

     float total;

./ ADD NAME=CBC3RAJ1 0100-00271-00271-1208-00017-00017-00000-BC0THOR
/*********************************************************************/
/* This program illustrates the use of file scope static variables.  */
/* part 1 of 2-other file is CBC3RAJ2.                               */
/*********************************************************************/

#include <stdio.h>
extern void var_print(void);
static stat_var = 1;

int main(void)
{
   printf("file1 stat_var = %d\n", stat_var);
   var_print();
   printf("FILE1 stat_var = %d\n", stat_var);

   return(0);
}
./ ADD NAME=CBC3RAJ2 0100-00271-00271-1203-00012-00012-00000-BC0THOR
/*********************************************************************/
/* This example illustrates the use of file scope static variables.  */
/* part 2 of 2-other file is CBC3RAJ1.                               */
/*********************************************************************/

#include <stdio.h>
static int stat_var = 2;

void var_print(void)
{
    printf("file2 stat_var = %d\n", stat_var);
}
./ ADD NAME=CBC3RAR1 0100-00269-00269-1345-00015-00015-00000-BC0THOR
/*********************************************************************/
/* This example uses an abstract data type.                          */
/* part 2 of 2-other file is CBC3RAAR.                               */
/*********************************************************************/

#ifndef __INTERFACE__
  #define __INTERFACE__

  typedef struct ControlBlock_T ControlBlock;

  ControlBlock* GetControlBlock(){};
  int UpdateControlBlock(ControlBlock* value1, int value2){};
  int UseControlBlock(ControlBlock* value3){};

#endif
./ ADD NAME=CBC3RMAX 0100-00269-00269-1044-00014-00014-00000-BC0THOR
/*********************************************************************/
/* This is an example of a C program called by another C program,    */
/* CBC3RAAB. CBC3RAAB passes two numbers. This program compares them */
/* and returns the larger of the two (or the second, if they are     */
/* equal).                                                           */
/*********************************************************************/

int max (int a,int b)                 /* Function  definition */
{
   if ( a > b )
       return (a);
   else
       return (b);
}
./ ADD NAME=CBC3UAAM 0100-00271-00271-1216-00042-00042-00000-BC0THOR
/*********************************************************************/
/* Converts celsius temperatures to fahrenheit.                      */
/* Part 1 of 2-parts. Other part is cbc3uaan.h                       */
/*********************************************************************/
#include <stdio.h>

#include "cbc3uaan.h"

void convert(double);

int main(int argc, char **argv)
{
    double c_temp;

    if (argc == 1) {  /* get Celsius value from stdin */
       int ch;

       printf("Enter Celsius temperature: \n");

       if (scanf("%f", &c_temp) != 1) {
          printf("You must enter a valid temperature\n");
       }
       else {
          convert(c_temp);
       }
    }
    else {  /* convert the command-line arguments to Fahrenheit */
       int i;

       for (i = 1; i < argc; ++i) {
           if (sscanf(argv[i], "%f", &c_temp) != 1)
              printf("%s is not a valid temperature\n",argv[i]);
           else
              convert(c_temp);
       }
    }
}

void convert(double c_temp) {
   double f_temp = (c_temp * CONV + OFFSET);
   printf("%5.2f Celsius is %5.2f Fahrenheit\n",c_temp, f_temp);
}
./ ADD NAME=CBC3UAAN 0100-00271-00271-1217-00008-00008-00000-BC0THOR
/*********************************************************************/
/*  User include file:  cbc3uaan.h                                   */
/*  Part 2 of a 2-part sample. First part is cbc3uaam.               */
/*********************************************************************/

#define CONV   (9./5.)
#define OFFSET 32

./ ADD NAME=CBC3X06C 0100-00271-00271-1243-00020-00020-00000-BC0THOR
/*********************************************************************/
/* This example illustrates function calls.                          */
/*********************************************************************/

#include <stdio.h>
void func (int a, int b);

int main(void)
{
   int x = 5, y = 7;

   func(x, y);
   printf("In main, x = %d    y = %d\n", x, y);
}

void func (int a, int b)
{
   a += b;
   printf("In func, a = %d    b = %d\n", a, b);
}
./ ADD NAME=CBC3X08A 0100-00271-00271-1248-00022-00022-00000-BC0THOR
/*********************************************************************/
/* This example illustrates the __FUNCTION__ predefined macro        */
/* in a C program.                                                   */
/*********************************************************************/
#include <stdio.h>

int foo(int);

main(int argc, char **argv) {
   int k = 1;
   printf (" In function %s \n",__FUNCTION__);
   foo(k);
}

int foo (int i) {
   printf (" In function %s \n",__FUNCTION__);
}
/**
 ** The output of this example is:
 **      In function main
 **      In function foo
 **/
./ ADD NAME=CBC3YIV1 0100-00271-00271-1313-00024-00024-00000-BC0THOR
/*********************************************************************/
/* Echo arguments to STDOUT                                          */
/*********************************************************************/
#include <stdio.h>
#define NUM_CHARS 36
int i;
int main(ac, av)
    int  ac;
    char *av[];
    {
    i= 0;
    ++av, --ac;
    for (; 0 < ac; ++av, --ac)
        {
        i= i + printf("%s", *av);
        if (1 < ac)
            printf(" ");
        else
            printf("\n");
        }
    i= NUM_CHARS - i;
    if (i < 0) i= -i;
    exit(i);
    }
./ ADD NAME=CBRAKETS 0100-00277-00277-0952-00068-00068-00000-BC0THOR
         TITLE '*****CBRAKETS: CONVERT C PROGRAM BRACKETS *****'
CBRAKETS SVLNK R3
         PRINT NOGEN
***********************************************************************
* CONVERT THE VARIANT CHARACTERS IN A C SOURCE PROGRAM TO THE VALUES  *
* USED BY THE C COMPILER. AT PRESENT:                                 *
*                                                                     *
*               C COMPILER       REFLECTIONS                          *
*               --------------   -------------------                  *
* LEFT BRACKET  X'AD' Y-UMLAUT   X'BA' LEFT BRACKET                   *
*                                                                     *
* RIGHT BRACKET X'BD' QUOTE      X'BB' RIGHT BRACKET                  *
*                                                                     *
* CIRCUMFLEX    X'5F' CIRCUMFLEX X'B0' CIRCUMFLEX                     *
*                                                                     *
* TO SATISFY THE COMPILER, X'BA' IS CONVERTED TO X'AD' FOR THE LEFT   *
* BRACKET, X'BB' IS CONVERTED TO X'BD' FOR THE RIGHT BRACKET, AND     *
* X'B0' IS CONVERTED TO X'5F' FOR THE CIRCUMFLEX (HAT).               *
*                                                                     *
* AUTHOR R THORNTON AUG 2000                                          *
***********************************************************************
*
***********************************************************************
* INITIALIZATION: OPEN FILES                                          *
***********************************************************************
         OPEN  (SYSOUT,OUTPUT,SYSIN)   OPEN FILES
***********************************************************************
* MAINLINE PROCESSING: READ-TRANSLATE-WRITE THROUGH ENTIRE INPUT FILE.*
***********************************************************************
MAINLINE GET   SYSIN,RECORD            READ SYSIN RECORD
         TR    RECORD,XLATE            TRANSLATE BRACKETS
         PUT   SYSOUT,RECORD           WRITE TRANSLATED RECORD
         B     MAINLINE                LOOP THRU SYSIN FILE.
***********************************************************************
*        END OF INPUT FILE AND END OF JOB                             *
***********************************************************************
EOJ      CLOSE (SYSIN,,SYSOUT)         CLOSE FILES
         L     R13,4(R13)              GET CALLER'S SAVE ADDRESS
         LM    R14,R12,12(R13)         RESTORE CALLER'S REGS
         SR    R15,R15                 ZERO RETURN CODE
         BR    R14                     RETURN TO CALLER
***********************************************************************
*        STORAGE AND FILE AREAS                                       *
***********************************************************************
RECORD   DS    CL80                    RECORD STORAGE AREA
XLATE    DS    0D                      TRANSLATION TABLE
         DC    XL16'000102030405060708090A0B0C0D0E0F' 00-0F
         DC    XL16'101112131415161718191A1B1C1D1E1F' 10-1F
         DC    XL16'202122232425262728292A2B2C2D2E2F' 20-2F
         DC    XL16'303132333435363738393A3B3C3D3E3F' 30-3F
         DC    XL16'404142434445464748494A4B4C4D4E4F' 40-4F
         DC    XL16'505152535455565758595A5B5C5D5E5F' 50-5F
         DC    XL16'606162636465666768696A6B6C6D6E6F' 60-6F
         DC    XL16'707172737475767778797A7B7C7D7E7F' 70-7F
         DC    XL16'808182838485868788898A8B8C8D8E8F' 80-8F
         DC    XL16'909192939495969798999A9B9C9D9E9F' 90-9F
         DC    XL16'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF' A0-AF
         DC    XL16'5FB1B2B3B4B5B6B7B8B9ADBDBCBDBEBF' B0-BF B0, BA, BB
         DC    XL16'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF' C0-CF
         DC    XL16'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF' D0-DF
         DC    XL16'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF' E0-EF
         DC    XL16'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF' F0-FF
SYSIN    DCB   DSORG=PS,MACRF=GM,DDNAME=SYSIN,EODAD=EOJ,               X
               RECFM=FB,LRECL=80
SYSOUT   DCB   DSORG=PS,MACRF=PM,DDNAME=SYSOUT,                        X
               RECFM=FB,LRECL=80
         LTORG
         END
./ ADD NAME=CCMP     0100-00294-00294-1527-00028-00028-00000-BC0THOR
/*********************************************************************/
/*   PURPOSE: SUBMITS A C COMPILE/BIND FOR THE MEMBER BEING EDITED   */
/*            USING THE JCL IN PDS.JCL(EDCCB) AS MODIFIED BY EDIT    */
/*            MACRO CEDIT WHICH IS INVOKED BY THIS EDIT MACRO.       */
/*   AUTHOR:  BC0THOR (DICK THORNTON) CREATION DATE: 08/17/2000      */
/*   TYPICAL USER(S): BC0THOR                                        */
/*   PARAMETERS PASSED: NONE                                         */
/*   CDC COMPLIANCE: NO CDC DATE DEPENDENCIES                        */
/*********************************************************************/
/*   MAINTENANCE RECORD: LAST 3 CHANGES                              */
/*********************************************************************/
/*   DATE    LOGONID REASON FOR CHANGE & WHAT WAS DONE               */
/*-------------------------------------------------------------------*/
/*08/17/2000 BC0THOR INITIAL CREATION                                */
/*                                                                   */
/*********************************************************************/
ISREDIT MACRO
CONTROL NOLIST NOSYMLIST NOCONLIST MSG
ISREDIT (CMBR) = MEMBER  /* GET NAME OF MEMBER BEING EDITED.         */
IF &CMBR = &STR() THEN DO
    SET &ZEDSMSG = &STR(NO MEMBER)
    SET &ZEDLMSG = &STR(MEMBER VARIABLE FROM ISPF IS NULL)
    ISPEXEC SETMSG MSG(ISRZ001)
    EXIT CODE(12)
    END
ISPEXEC VPUT (CMBR)        /* WRITE MEMBER NAME TO VARIABLE POOL     */
ISREDIT SAVE               /* SAVE MEMBER BEING EDITED               */
ISPEXEC EDIT DATASET(PDS.JCL(EDCCB)) MACRO(CEDIT)       /*EDIT,SUBMIT*/
./ ADD NAME=CEDIT    0100-00294-00294-1528-00024-00024-00000-BC0THOR
/*********************************************************************/
/*   PURPOSE: THIS EDIT MACRO IS CALLED BY EDIT MACRO CCMP TO CHANGE */
/*            THE JCL IN BC0THOR.PDS.ASM(EDCCB) SO THAT IT WILL      */
/*            COMPILE THE PROGRAM JUST EDITED WHEN THE CCMP MACRO    */
/*            WAS INVOKED. THE CCMP MACRO VPUTS THE MEMBER NAME IN   */
/*            POOL VARIABLE CMBR BEFORE INVOKING THIS MACRO.         */
/*   AUTHOR:  BC0THOR (DICK THORNTON) CREATION DATE: 08/17/2000      */
/*   TYPICAL USER(S): BC0THOR                                        */
/*   PARAMETERS PASSED: NONE                                         */
/*   CDC COMPLIANCE: NO CDC DATE DEPENDENCIES                        */
/*********************************************************************/
/*   MAINTENANCE RECORD: LAST 3 CHANGES                              */
/*********************************************************************/
/*   DATE    LOGONID REASON FOR CHANGE & WHAT WAS DONE               */
/*-------------------------------------------------------------------*/
/*08/17/2000 BC0THOR INITIAL CREATION                                */
/*                                                                   */
/*********************************************************************/
ISREDIT MACRO
CONTROL NOLIST NOSYMLIST NOCONLIST MSG
ISPEXEC VGET (CMBR)           /* GET MEMBER NAME SET BY CCMP MACRO   */
ISREDIT CHANGE ALL 'XXXXXXXX' '&CMBR'    /* CHANGE X'S TO MEMBER NAME*/
ISREDIT SUBMIT                /* SUBMIT RESULTING COMPILE/LKED JCL   */
ISREDIT CAN                   /* DON'T SAVE THE CHANGES TO EDCCB     */
./ ADD NAME=EDCCB    0100-00294-00294-1528-00060-00060-00000-BC0THOR
//BC0THORD JOB (1152002-9800039,,TMVS01-UR-XXXX),'DTHORNTON',CLASS=V,
//   MSGCLASS=Y,NOTIFY=BC0THOR,REGION=104M
//JESOUT OUTPUT GROUPID=02A,DEFAULT=YES,JESDS=ALL,
//   PAGEDEF=GRYBIG,FORMDEF=GRYBIG
//********************************************************************
//*                BC0THOR.PDS.JCL(EDCCB)                            *
//********************************************************************
//* DO NOT MODIFY THIS JCL: IT IS USED BY EDIT MACROS CCMP AND CEDIT *
//********************************************************************
//*  COMPILE AND BIND A C PROGRAM                                    *
//*                                                                  *
//*  SOURCE PROGRAM IS BC0THOR.PDS.C(XXXXXXXX)                       *
//*  OUTPUT LOAD MODULE IS BC0THOR.LOAD.LOAD(XXXXXXXX)               *
//*                                                                  *
//*  OS/390 C/C++  V2R6M0  5647-A01                                  *
//********************************************************************
//*-------------------------------------------------------------------
//*  CONVERT SQUARE BRACKETS TO COMPILER EXPECTED VALUES
//*-------------------------------------------------------------------
//CBRAKETS EXEC PGM=CBRAKETS
//STEPLIB  DD   DSN=BC0THOR.LOAD.LOAD,DISP=SHR
//SYSUDUMP DD   SYSOUT=*
//SYSIN    DD   DSN=BC0THOR.PDS.C(XXXXXXXX),DISP=SHR
//SYSOUT   DD   DSN=&&CSOURCE,DISP=(,PASS),
//         UNIT=DISK,SPACE=(CYL,(2,1),RLSE),
//         DSORG=PS,RECFM=FB,LRECL=80
//*-------------------------------------------------------------------
//*  COMPILE STEP:
//*-------------------------------------------------------------------
//COMPILE EXEC PGM=CBCDRVR,
//    PARM=('/AGG,EXP,LIS,OF,OPT,SO,XR,CHE(ALL)')
//STEPLIB  DD  DSN=CEE.SCEERUN,DISP=SHR
//         DD  DSN=CBC.SCBCCMP,DISP=SHR
//SYSLIB   DD  DSN=CEE.SCEEH.H,DISP=SHR
//         DD  DSN=CEE.SCEEH.SYS.H,DISP=SHR
//         DD  DSN=CBC.SCBCSAM,DISP=SHR
//SYSLIN   DD  DSN=&&LOADSET,DISP=(NEW,PASS),
//         UNIT=DISK,SPACE=(TRK,(3,3)),
//         RECFM=FB,LRECL=80,BLKSIZE=3200
//SYSPRINT DD  SYSOUT=*
//SYSOUT   DD  SYSOUT=*
//SYSCPRT  DD  SYSOUT=*
//SYSIN    DD  DSN=&&CSOURCE,DISP=(OLD,PASS,DELETE)
//*-------------------------------------------------------------------
//*  BIND STEP:
//*-------------------------------------------------------------------
//BIND   EXEC PGM=IEWL,COND=(4,LT,COMPILE),
//         PARM=(LIST,LET,MAP,XREF,CALL)
//STEPLIB  DD  DSN=CEE.SCEERUN,DISP=SHR
//SYSLIB   DD  DSN=CEE.SCEELKEX,DISP=SHR
//         DD  DSN=CEE.SCEELKED,DISP=SHR
//         DD  DSN=SYS1.IMSVS.RESLIB,DISP=SHR
//         DD  DSN=ISP.SISPLOAD,DISP=SHR
//         DD  DSN=BC0THOR.LOAD.LOAD,DISP=SHR
//SYSPRINT DD  SYSOUT=*
//SYSLIN   DD  DSN=&&LOADSET,DISP=(OLD,DELETE)
//         DD  DDNAME=SYSIN
//SYSLMOD  DD  DSN=BC0THOR.LOAD.LOAD(XXXXXXXX),DISP=SHR
//SYSDEFSD DD  DUMMY
//SYSIN    DD  DUMMY
